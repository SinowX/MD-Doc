## 进程相关系统调用

- ![](https://i.loli.net/2021/10/12/3IWhVg6kOmUNrcR.jpg)

### fork()

- ```c
  #include<unistd.h>
  
  pid_t fork(void);
  ```

- 在父进程中，成功返回 子进程 pid，失败返回 -1

- 在子进程中 ，总是返回 0

- 完成调用后，两个进程均从 fork 返回处继续执行（包括返回值赋值语句，用意在）

- 两进程执行相同的 程序文本段

- 两进程各自拥有不同的 栈段、数据段、堆段 拷贝

- 子进程 的 栈、数据、堆 开始时 是对父进程内存的相应各部分的 完全复制

- 执行 fork() 后，每个进程可修改各自的 栈数据、堆段中的变量，并不影响另一个进程

- 无法创建子进程的可能情况

  - 进程数量超出了对此 真实用户 在进程数量上 所施加的限制 RLIMIT_NPROC
  - 进程数量超出了系统上限

- 调用 fork 后，系统会先运行子进程还是父进程无法确定，注意避免竞争条件

- 模板

- ```c
  pid_t childPid;
  
  switch(childPid = fork()){
      case -1:
          /* err */
      case 0:
          /* action to child */
      default:
          /* action to parent */
  }
  ```

- 

- 即将父进程 一分为二

- ```c
      int istack = 222;               /* Allocated in stack segment */
      pid_t childPid;
  
      switch (childPid = fork()) {
      case -1:
          errExit("fork");
  
      case 0:
          idata *= 3;
          istack *= 3;
          break;
  
      default:
          sleep(3);                   /* Give child a chance to execute */
          break;
      }
  
      /* Both parent and child come here */
  
      printf("PID=%ld %s idata=%d istack=%d\n", (long) getpid(),
              (childPid == 0) ? "(child) " : "(parent)", idata, istack);
  
      exit(EXIT_SUCCESS);
  ```

-  

#### 父子进程文件共享

- 执行 fork 之后， 子进程获得父进程 所有 文件描述符 副本，创建方法 类似于 dup() 
- 父、子进程中 对应的描述符均指向相同的 打开文件句柄 open file description
- 打开文件句柄包含有当前 文件偏移量、文件状态，父子共享
- 共享文件偏移量，确保了父子不会覆盖彼此的输入内容，要进一步规避数据混杂，需要进程间同步，比如，可以调用 wait() 来暂停运行并等待子进程退出
- 若要避免 共享文件偏移量，可以
  - 父子进程使用不同文件描述符，可令子进程重新打开文件
  - 父子进程关闭文件描述符，对文件的操作由另一进程来使用

#### 父子进程的共享 避免 资源开销

- 内核 将每一进程代码段标记为制度，使进程无法修改代码，其所构建的一系列进程级页表项，均指向与父进程相同的物理内存 页帧

- 内核 对 父进程 的 数据段、堆段、栈段 的页 采用 写时复制 技术

- 过程
  - 先令这些段的页表指向父进程相同的物理内存页，标记为只读
  - 调用 fork 后
  - 内核捕获所有父进程 或 子进程针对这些页面的修改企图
  - 将要修改的 页面创建拷贝
  - 系统将新页面的拷贝分配给 被捕获修改企图的 进程，对子进程的相应表项做适当调整
  - 父子进程可以分别修改各自的页拷贝，互不影响
  
- 控制进程的内存需求

  - 通过fork() 与 wait() 的组合使用，可以控制一个进程的需求

  - 调用函数而不改变进程的需求量

    - ```c
      pid_t childPid;
      int status;
      
      childPid = fork();
      if(childPid == -1)
          errExit("fork");
      
      if(childPid == 0)
      	exit(func(arg));
      
      if(wait(&status) == -1)
          errExit("wait");
      ```

#### vfork()

- 除非能给性能呢该带来重大提升（概率极小），否则应当避免使用 vfork

- ```c
  #include<unistd.h>
  
  pid_t vfork(void);
  ```

- 在父进程中，成功返回 子进程 pid，失败返回 -1

- 在子进程中 ，总是返回 0

- 特性

  - 无需为子进程复制虚拟内存页或页表，子进程共享父进程的内存，直至其成功执行了 exec() 或是 调用 _exec() 退出
  - 在子进程调用 exec() 或 _exec() 之前，将暂停执行父进程

- 特性导致了在子进程的行为会影响父进程，最终结果可能会是 SIGSEGV 报错



#### fork() 竞争条件

- 不应假设 fork 之后，父子进程哪个先运行，需要采用 同步技术，包括 信号量、文件锁、管道、信号



#### 同步信号以规避竞争条件

- 建议将此类同步方法封装为一组标准进程的同步函数，以便之后可以IPC机制替换信号使用

- ```c
  #include <signal.h>
  #include "curr_time.h"                  /* Declaration of currTime() */
  #include "tlpi_hdr.h"
  
  #define SYNC_SIG SIGUSR1                /* Synchronization signal */
  
  static void             /* Signal handler - does nothing but return */
  handler(int sig)
  {
  }
  
  int
  main(int argc, char *argv[])
  {
      pid_t childPid;
      sigset_t blockMask, origMask, emptyMask;
      struct sigaction sa;
  
      setbuf(stdout, NULL);               /* Disable buffering of stdout */
  
      sigemptyset(&blockMask);
      sigaddset(&blockMask, SYNC_SIG);    /* Block signal */
      if (sigprocmask(SIG_BLOCK, &blockMask, &origMask) == -1)
          errExit("sigprocmask");
  
      sigemptyset(&sa.sa_mask);
      sa.sa_flags = SA_RESTART;
      sa.sa_handler = handler;
      if (sigaction(SYNC_SIG, &sa, NULL) == -1)
          errExit("sigaction");
  
      switch (childPid = fork()) {
      case -1:
          errExit("fork");
  
      case 0: /* Child */
  
          /* Child does some required action here... */
  
          printf("[%s %ld] Child started - doing some work\n",
                  currTime("%T"), (long) getpid());
          sleep(2);               /* Simulate time spent doing some work */
  
          /* And then signals parent that it's done */
  
          printf("[%s %ld] Child about to signal parent\n",
                  currTime("%T"), (long) getpid());
          if (kill(getppid(), SYNC_SIG) == -1)
              errExit("kill");
  
          /* Now child can do other things... */
  
          _exit(EXIT_SUCCESS);
  
      default: /* Parent */
  
          /* Parent may do some work here, and then waits for child to
             complete the required action */
  
          printf("[%s %ld] Parent about to wait for signal\n",
                  currTime("%T"), (long) getpid());
          sigemptyset(&emptyMask);
          if (sigsuspend(&emptyMask) == -1 && errno != EINTR)
              errExit("sigsuspend");
          printf("[%s %ld] Parent got signal\n", currTime("%T"), (long) getpid());
  
          /* If required, return signal mask to its original state */
  
          if (sigprocmask(SIG_SETMASK, &origMask, NULL) == -1)
              errExit("sigprocmask");
  
          /* Parent carries on to do other things... */
  
          exit(EXIT_SUCCESS);
      }
  }
  
  ```

Q

### exit()

- ```c
  #include<unistd.h>
  
  void _exit(int status);
  ```

- status 定义了终止状态，父进程通过 wait() 来获取该状态

- _exit 总会成功终止

- 注意：父进程获取的 状态 status 仅有低 8 位 可用

  - status 可在 0~255 间 任意取值，并传递给父进程 与 信号值之和
  - 但是在与 shell 脚本结合时，会引发混乱
    - 当 信号终止一命令时，shell会将变量 $? 置为 128 与 信号值之和
    - 若这与进程调用 _exit() 时用的 status 值 混杂起来， 会令 shell 无法区分

- 将进程占用的所有资源， 内存、文件描述符等 归还内核

- status 为一整型变量，表示进程退出状态

- 父进程调用 wait() 来获取 子进程退出状态

  - 按照惯例，status 为 0，正常退出；status 为 非 0，异常而退出
  - 异常状态码无同意规定，但 SUSv3 规定两个常量 EXIT_SUCCESS(0) EXIT_FAILURE(1)

- ```c
  #include<stdlib.c>
  
  void exit(int status);
  ```

- 执行动作

  - 调用退出处理程序（通过atexit() 和 on_exit() 注册的函数），执行顺序与注册顺序相反
  - 刷新 stdio 流缓冲区
  - 使用由 status 提供的值 执行 _exit() 系统调用

- return n 等同于 exit(n)

  - 有一种情况下不同
  - 若退出处理过程中，执行的任何步骤需要访问main() 函数 本地变量，则从 main() 中 返回 会 导致为定义的行为

#### 进程终止细节

- 关闭所有打开文件描述符、目录流、信息目录描述符、字符集转换描述符
- 释放该进程所持有的任何文件锁
- 分离（detach） 任何一链接的 System V 共享内存段，且对应于各段的 shm_nattch 计数器值减一
- 进程为每个 System V 信号量所设置的 semadj 值将会被加到信号量值中
- 若该进程是一个管理终端 terminal 的管理进程，系统会向该终端前台 foreground 进程组中的每个进程 发送 SIGHUP 信号，接着终端会与 对话 session 分离
- 将关闭该进程打开的任何POSIX有名的信号量，类似于调用 sem_close()
- 关闭该进策划那个打开的任何POSIX消息队列，类似于调用 mq_close()
- 若某进程组成为孤儿，且该组中存在任何已停止进程，则组中所有进程都将收到 SIGHUP 信号，随之为 SIGCONT 信号
- 移除该进程通过 mlock() 或 mlockall() 所建立的任何内存锁
- 取消该进程调用 mmap() 所创建的人呢和内存映射 （mapping）

#### 退出处理程序

- 退出处理程序，

  - 于进程生命周期的任意点时注册
  - 在该进程调用 exit() 正常终止时自动执行
  - 直接调用_exit() 或 因信号意外终止，不会自动调用 退出处理程序

- 注册退出处理程序

- ```c
  #include<stdlib.c>
  
  int atexit(void (*func)(void*));
  ```

- 成功返回 0

- 失败返回 非0

- 函数 atexit 将func 加到一个函数列表中，进程终止时会调用该函数列表的所有函数，不接受任何参数，无返回值

- ```c
  void func(void)
  {
      /* actions */
  }
  ```

- 可以注册多个退出处理程序

- exit() 调用时，这些函数于注册顺序相反

- SUSv3 规定

  - 禁止在 退出处理程序 中调用 exit()
  - 系统应允许一个进程能够注册 至少 32 个 退出处理程序

- 在进程内部即可调用 sysconf(_SG_ATEXIT_MAX) 来确定由实现所定义的可注册退出处理程序的数量上限，但是无法获取当前已注册的 退出处理程序 数量

- fork() 创建的子进程会继承父进程注册的 退出处理程序

  - 进程调用 exec() 时，会一处所有已注册的退出处理程序

- 无法取消经由 atexit() 或 on_exit() 注册的退出处理程序

  - 但是可以令退出处理程序在执行动作之前检查全局执行标志是否置位
  - 或直接清除该标志来屏蔽退出处理程序

- 由 atexit() 注册的 退出处理程序 受到的限制

  - 退出处理程序在执行时无法获知传递给 exit() 的状态
  - 无法给退出处理程序指定参数

- ```c
  #define _BSD_SOURCE
  #include<stdlib.h>
  
  int on_exit(void (*func)(int, void *), void *arg);
  ```

- 成功返回 0

- 错误返回 非0

- 参数 func 是一个指针，指向函数

- ```c
  void func(int status, void * arg){
      /* actions */
  }
  ```

- 调用时，传递两个参数给 func()

  - 提供给 exit() 的 status 参数和注册时供给 on_exit() 的一份 arg 参数拷贝
  - arg 参数虽然为指针类型， 其意义仍然可以由设计者支配，比如 用作指向结构的指针，强制转换（足够小心）为整型或其他标量类型

- atexit() on_exit() 注册的函数位于同一函数列表

- 注意：为了保障可移植性，应避免使用 on_exit()，没有标准规定过，几乎没有其他UNIX支持

- ```c
  #define _BSD_SOURCE     /* Get on_exit() declaration from <stdlib.h> */
  #include <stdlib.h>
  #include "tlpi_hdr.h"
  
  static void
  atexitFunc1(void)
  {
      printf("atexit function 1 called\n");
  }
  
  static void
  atexitFunc2(void)
  {
      printf("atexit function 2 called\n");
  }
  
  static void
  onexitFunc(int exitStatus, void *arg)
  {
      printf("on_exit function called: status=%d, arg=%ld\n",
                  exitStatus, (long) arg);
  }
  
  int
  main(int argc, char *argv[])
  {
      if (on_exit(onexitFunc, (void *) 10) != 0)
          fatal("on_exit 1");
      if (atexit(atexitFunc1) != 0)
          fatal("atexit 1");
      if (atexit(atexitFunc2) != 0)
          fatal("atexit 2");
      if (on_exit(onexitFunc, (void *) 20) != 0)
          fatal("on_exit 2");
  
      exit(2);
  }
  
  ```

  

#### fork() stdio 缓冲区 以及 _exit() 之间的交互

- 





### wait()

#### wait()

- ```c
  #include<sys/wait.h>
  
  pid_t wait(int *status);
  ```

  

- 成功返回终止子进程PID

- 错误返回 -1

  - 可能调用进程并无之前未被等待的子进程，此时errno 置为 ECHILD

    - 等待调用进程的所有子进程退出

    - ```c
      while((childPid = wait(NULL)) != -1)
          continue;
      if (errno != ECHILD)
          errExit("wait");
      ```

- 若父进程调用 wait() 之前，无子进程终止，则调用将一直阻塞，直至某个子进程终止；若已有子进程终止，则 wait() 立即返回

- 若 status 非空，则关于子进程如何终止的信息则会通过 status 指向的整型变量返回

- 内核将会为父进程下所有子进程的运行总量追加 进程CPU时间 以及 资源使用数据

- 将终止子进程的 ID 作为 wait() 的结果返回

- 同一时间点存在多个子进程退出，wait() 处理这些子进程的顺序未被规定

- 限制

  - 父进程无法等待某个特定子进程的终止
  - 若没有子进程退出，wait() 总是保持阻塞
  - 使用 wait() 只能发现那些已经终止的子进程，
  - 无法发现因信号（SIGTOP SIGTTIN）而停止的子进程
  - 无法处理 已停止进程，收到SIGCONT信号后回复执行的情况

- 创建并等待多个子进程

- ```c
  #include <sys/wait.h>
  #include <time.h>
  #include "curr_time.h"              /* Declaration of currTime() */
  #include "tlpi_hdr.h"
  
  int
  main(int argc, char *argv[])
  {
      int numDead;       /* Number of children so far waited for */
      pid_t childPid;    /* PID of waited for child */
      int j;
  
      if (argc < 2 || strcmp(argv[1], "--help") == 0)
          usageErr("%s sleep-time...\n", argv[0]);
  
      setbuf(stdout, NULL);           /* Disable buffering of stdout */
  
      for (j = 1; j < argc; j++) {    /* Create one child for each argument */
          switch (fork()) {
          case -1:
              errExit("fork");
  
          case 0:                     /* Child sleeps for a while then exits */
              printf("[%s] child %d started with PID %ld, sleeping %s "
                      "seconds\n", currTime("%T"), j, (long) getpid(),
                      argv[j]);
              sleep(getInt(argv[j], GN_NONNEG, "sleep-time"));
              _exit(EXIT_SUCCESS);
  
          default:                    /* Parent just continues around loop */
              break;
          }
      }
  
      numDead = 0;
      for (;;) {                      /* Parent waits for each child to exit */
          childPid = wait(NULL);
          if (childPid == -1) {
              if (errno == ECHILD) {
                  printf("No more children - bye!\n");
                  exit(EXIT_SUCCESS);
              } else {                /* Some other (unexpected) error */
                  errExit("wait");
              }
          }
  
          numDead++;
          printf("[%s] wait() returned child PID %ld (numDead=%d)\n",
                  currTime("%T"), (long) childPid, numDead);
      }
  }
  ```

- 

#### waitpid()

- ```c
  #include<sys/wait.h>
  
  pid_t waitpid(pid_t pid, int *status, int options);
  ```

- 成功返回 PID

- 错误返回 0 或 -1

- 参数 status

  - 若 status 非空，则关于子进程如何终止的信息则会通过 status 指向的整型变量返回

- 参数 pid

  - 若大于 0，表示等待进程的 PID
  - 若等于 0，表示等待与调用进程同一个进程组的所有子进程
  - 若小于 -1，则会等待进程组标识符与 pid 绝对值相等的所有子进程
  - 若等于 -1，则等待任意子进程，即 wait( &status ) 的调用 与 waitpid(-1, &status, 0) 等价

- 参数 option 是一个 位掩码（bit mask），可用标志如下

  - | 标志       | 说明                                                         |
    | ---------- | ------------------------------------------------------------ |
    | WUNTRACED  | 除返回终止子进程信息外，还返回因信号而停止的子进程信息       |
    | WCONTINUED | 返回因收到 SIGCONT 信号而恢复执行的已停止子进程的状态信息    |
    | WNOHANG    | 若pid所指定的子进程未改变，则立即返回，不会阻塞，轮询poll，返回 0；若无与pid匹配的子进程，则错误好置为 ECHILD |



#### status 等待状态值

- wait() waitpid() 返回 status 值，可以区分以下子进程事件

  - 子进程调用 _exit() 或 exit() 而终止，并指定一个整型值作为退出状态
  - 子进程收到未处理信号而终止，（ 杀死？）
  - 子进程因为信号而停止，并以 WUNTRACED 标志调用 waitpid()
  - 子进程因收到信号 SIGCONT 而恢复，并以 WCONTINUED 标志调用 waitpid()
  - 用“等待状态”上述涵盖所有情况，“终止状态”指代前两种情况，shell 中 `$?` 获取上次执行命令的终止状态

- status 未 int，但实际上仅使用了最低的两个字节，两个字节的填充方式取决于子进程发生的具体事件

  - SUSv3 未对信息格式作出具体规定，也未规定只是用最低两个字节，要保证可移植性，应总是使用 宏 来获取相应的值

  - ![](https://i.loli.net/2021/10/12/DcOgUjwQ1u3Ax6i.jpg)

  - \<sys/wait.h\> 定义了用于解析等待状态值的一组标准宏，对来自 wait() waitpid() 返回的 status 值处理时，下列宏只有一个返回 true 

  - | 宏                   | 说明                                                         |
    | :------------------- | ------------------------------------------------------------ |
    | WIFEXITED(status)    | 子进程正常结束则返回 true，WEXITSTATUS(status) 返回子进程的退出状态 |
    | WIFSIGNALED(status)  | 子进程被信号杀死则返回 true，WTERMSIG(status) 返回导致子进程终止的信号编号。若子进程产生内核转储文件，则宏WCOREDUMP(status) 返回 true，SUSv3 未规范 WCOREDUMP()，不过大部分 UNIX 均支持 |
    | WIFSTOPPED(status)   | 子进程因信号而停止则返回 true，此时， WSTOPSIG(status) 返回导致子进程停止的信号编号 |
    | WIFCONTINUED(status) | 子进程受到 SIGCONT 而恢复执行则返回 true，                   |

  - 尽管上述宏的参数也是用 status 命名，不过此处指的是整型变量，而不是 wait waitpid 的整型指针

  - ```c
    #include <sys/wait.h>
    #include "print_wait_status.h"          /* Declares printWaitStatus() */
    #include "tlpi_hdr.h"
    
    int
    main(int argc, char *argv[])
    {
        int status;
        pid_t childPid;
    
        if (argc > 1 && strcmp(argv[1], "--help") == 0)
            usageErr("%s [exit-status]\n", argv[0]);
    
        switch (fork()) {
        case -1: errExit("fork");
    
        case 0:             /* Child: either exits immediately with given
                               status or loops waiting for signals */
            printf("Child started with PID = %ld\n", (long) getpid());
            if (argc > 1)                   /* Status supplied on command line? */
                exit(getInt(argv[1], 0, "exit-status"));
            else                            /* Otherwise, wait for signals */
                for (;;)
                    pause();
            exit(EXIT_FAILURE);             /* Not reached, but good practice */
    
        default:            /* Parent: repeatedly wait on child until it
                               either exits or is terminated by a signal */
            for (;;) {
                childPid = waitpid(-1, &status, WUNTRACED
    #ifdef WCONTINUED       /* Not present on older versions of Linux */
                                                    | WCONTINUED
    #endif
                        );
                if (childPid == -1)
                    errExit("waitpid");
    
                /* Print status in hex, and as separate decimal bytes */
    
                printf("waitpid() returned: PID=%ld; status=0x%04x (%d,%d)\n",
                        (long) childPid,
                        (unsigned int) status, status >> 8, status & 0xff);
                printWaitStatus(NULL, status);
    
                if (WIFEXITED(status) || WIFSIGNALED(status))
                    exit(EXIT_SUCCESS);
            }
        }
    }
    
    ```

  - ```bash
    [sinow@SiMaj procexec]$ ./child_status 23
    Child started with PID = 3606
    waitpid() returned: PID=3606; status=0x1700 (23,0)
    child exited, status=23
    [sinow@SiMaj procexec]$ ./child_status &
    [1] 3608
    [sinow@SiMaj procexec]$ Child started with PID = 3609
    
    [sinow@SiMaj procexec]$ kill -STOP 15871
    bash: kill: (15871) - No such process
    [sinow@SiMaj procexec]$ kill -STOP 3609
    waitpid() returned: PID=3609; status=0x137f (19,127)
    child stopped by signal 19 (Stopped (signal))
    [sinow@SiMaj procexec]$ kill -CONT 3609
    waitpid() returned: PID=3609; status=0xffff (255,255)
    child continued
    [sinow@SiMaj procexec]$ kill -ABRT 3609
    [sinow@SiMaj procexec]$ waitpid() returned: PID=3609; status=0x0086 (0,134)
    child killed by signal 6 (Aborted) (core dumped)
    
    [1]+  Done                    ./child_status
    ```

- 从信号处理程序中终止进程

  - 通过wait() waitpid() 调用，父进程依然可以获取子进程的终止状态

    - 如在信号处理程序中调用 _exit(EXIT_SUCCESS) ，父进程会认为子进程是正常终止

  - 如果需要通知父进程自己因某个信号而终止，则子进程的信号处理程序应首先将自己废除，再发出相同信号，信号将终止这一子进程

  - 信号处理程序需包含如下代码

  - ```c
    void handler(int sig)
    {
        /* perform cleanup steps */
        signal(sig, SIG_DFL); // Dis-establish handler
        raise(sig); //Raise signal again
    }
    ```

#### waitid()



### execve()

- ```C
  #include<unistd.h>
  
  int execve(const char *pathname, char *const argv[], char *const envp[]);
  ```

- 成功不返回

- 错误返回 -1

- 参数 pathname

  - 将要载入当前进程空间的新程序的路径名
  - 绝对路径 或 相对路径

- 参数 argv 指定了传递给新进程的命令行参数，对应于 main() 中的 参数 argv

  - 由字符串指针所组成的列表，以NULL结束
  - argv[0] 值对应于命令名，常与pathname中的 basename 相同

- 参数 envp 指定了新程序的环境列表

  - 对应于新程序的 environ 数组，字符串指针组成的列表，以 NULL 结束
  -  name=value

- Linux  /proc/PID/exe 符号链接指向进程正在运行可执行文件的绝对路径名

- execve加载一个新程序到当前进程

- 即 将 当前进程的 栈、数据段、堆 为新程序重新创建

- 若 pathname 所指定的程序文件设置了 set-user-ID set-group-ID 权限位，则系统调用会在执行此文件时将 进程的 有效用户、组 ID 设置为 程序文件的属主 ID

  - 利用此特性，可令用户在运行特定程序时临时获取特权

- execve() 返回即为出错，出错原因由 errno 来判断

- | 宏      | 说明                                                         |
  | ------- | ------------------------------------------------------------ |
  | EACCES  | pathname 指向 无可执行权限；在basename 之前 某目录  不可搜索；以 MS_NOEXEC 标志来挂载 文件所在的文件系统 |
  | ENOENT  | pathname 指代文件不存在                                      |
  | ENOEXEC | pathname 指代文件赋予了可执行权限，但系统无法识别文件格式。如脚本文件没有指定 脚本解释器 #! 开头 |
  | ETXTBSY | 一个或多个进程已经以写入方式打开 pathname 所指代的文件       |
  | E2BIG   | 参数列表和环境列表 所需空间松和超出允许最大值                |

- ```c
  extern char **environ;
  
  int
  main(int argc, char *argv[])
  {
      int j;
      char **ep;
  
      for (j = 0; j < argc; j++)
          printf("argv[%d] = %s\n", j, argv[j]);
  
      for (ep = environ; *ep != NULL; ep++)
          printf("environ: %s\n", *ep);
  
      exit(EXIT_SUCCESS);
  }
  ```



#### exec() 库函数

- ```c
  #include<unistd.h>
  
  int execle(const *pathname, const char *arg, ...);
  int execlp(const char *filename, const char *arg, ...);
  int execvp(const char *filename, char *const argv[]);
  int execv(const char *pathname, char *const argv[]);
  int execl(const char *pathname, const char *arg, ...);
  ```

- 成功不返回，错误返回 -1

- 差异说明

  - pathname or filename
    - execlp() execvp() 允许只提供 filename ，系统会在 环境变量 PATH 指定的目录列表寻找相应的可执行文件；若文件名中包含 / ，则视为路径
    - 这两个库函数名都包含 p PATH

  - execle() execlp() execl() 要求以字符串列表来指定参数，而不是数组来描述 argv 列表
    - 必须以NULL指针来终止参数列表，以便于调用定位列表的尾部
    - 函数名 包含 l LIST
    - execvp() execv() 包含 v VECTOER
  - execve() execle() 允许通过 envp 显式指定环境变量，
    - envp 是以 NULL 结尾的字符串指针数组
    - 函数名包含 e ENVIRONMENT

- | 函数     | 对程序文件的描述 | 对参数的描述 | 环境变量来源   |
  | -------- | ---------------- | ------------ | -------------- |
  | execve() | 路径名           | 数组         | envp 参数      |
  | execle() | 路径名           | 列表         | envp 参数      |
  | execlp() | 文件名+PATH      | 列表         | 调用者 envrion |
  | execvp() | 文件名+PATH      | 数组         | 调用者 envrion |
  | execv()  | 路径名           | 数组         | 调用者 envrion |
  | execl()  | 路径名           | 列表         | 调用者 envrion |

- 避免在设置了 set-user-ID set-group-ID 的程序调用 execvp() execlp()

  - 特别谨慎控制 PATH 环境变量，以防运行恶意程序
  -  应该使用已知安全的目录列表来覆盖之前定义的任何 PATH 值

- 将程序参数指定为列表

  - 若已知参数个数，调用 execle() execlp() execl() 时可以将参数作为列表传入

  - ```c
    #include "tlpi_hdr.h"
    
    int
    main(int argc, char *argv[])
    {
        char *envVec[] = { "GREET=salut", "BYE=adieu", NULL };
        char *filename;
    
        if (argc != 2 || strcmp(argv[1], "--help") == 0)
            usageErr("%s pathname\n", argv[0]);
    
        filename = strrchr(argv[1], '/');       /* Get basename from argv[1] */
        if (filename != NULL)
            filename++;
        else
            filename = argv[1];
    
        execle(argv[1], filename, "hello world", "goodbye", (char *) NULL, envVec);
        errExit("execle");          /* If we get here, something went wrong */
    }
    ```

- 将调用者环境传递给新程序

  - execlp execvp execl execv 不允许显式指定环境列表，新程序环境继承自调用进程

  - ```c
    #include <stdlib.h>
    #include "tlpi_hdr.h"
    
    int
    main(int argc, char *argv[])
    {
        printf("Initial value of USER: %s\n", getenv("USER"));
        if (putenv("USER=britta") != 0)
            errExit("putenv");
    
        execl("/usr/bin/printenv", "printenv", "USER", "SHELL", (char *) NULL);
        errExit("execl");           /* If we get here, something went wrong */
    }
    ```

- fexecve()

  - ```c
    #define _GNU_SOURCE
    
    #include<unistd.h>
    
    int fexecve(int fd, char *const argv[], char *const envp[]);
    ```

  - 成功不返回，错误返回 -1
  
  - 行为与 execve() 类似，指定的程序是以打开文件描述符的方式
  
  - 有些应用程序需要通过执行校验和 checksum 来验证文件内容，然后再运行该程序
  
    - 也可以先调用open 验证，之后再运行，但是不能保证 打开文件 与 执行文件 的一致性（持有打开文件描述符并不能组织创建同名新文件）

#### 解释器脚本

```bash
#! interpreter-path [optional-arg]
```

- 解释该路径名时不会使用 PATH，一般采用绝对路径

- Linux 内核要求脚本的 #! 起始行不得超过127 个字节，不包括行为的换行符，超出部分会略去

- 调用 execve() 来运行脚本时

  - 若检测到传入文件以两字节序列 “#!” 开始，会解析该行的剩余部分

  - ```bash
    interpreter-path [optional-arg] script-path arg...
    ```

  - script-path 是底给execve 的 路径名， arg ... 是通过 变量 argv 传递给 execve 的参数列表（除 argv[0]）

  - ![](https://i.loli.net/2021/10/12/ob4eXT7RMfEjYOW.jpg)

- optional-arg可选参数

  - 可选参数的用途之一是为解释器指定命令行参数

  - awk 解释器

    - awk 默认将脚本作为awk 的首个命令行参数

      - ```bash
        awk 'script' input-file...
        ```

    - 也可以将 awk 脚本保存于文件之中

      - ```bash
        cat longest_line.awk
        #!/usr/bin/awk
        length > max { max = length; }
        END	{print max;}
        ```

    - 执行这一脚本文件

    - ```c
      execl("longest_line.awk","longest_line.awk","input.txt", (char *) NULL);
      ```

    - execl  调用 execve ，以如下参数列表来运行 awk

    - ```bash
      /usr/bin/awk longest_line.awk input.txt
      ```

    - awk 会把字符串 longest_line.awk 解释为一个包含无效awk 命令的脚本，故 execve() 调用失败

    - 在脚本的 起始行 加入参数 -f ，告知 awk 后面的参数是一个脚本文件

    - ```bash
      #!/usr/bin/awk -f
      length > max { max = length; }
      END	{print max;}
      ```

    - 现在，新的 execl() 调用会使用如下参数列表

    - ```bash
      /usr/bin/awk -f longest_line.awk input.txt
      ```

- execlp() execvp() 执行脚本

  - 会扫描PATH 来获取目录列表，并在其中搜索将要执行的文件
    - 若找到该文件，既具有可执行权限，又非二进制格式，且起始行不以 #! 开始，则会用 shell 来解释这一文件。Linux会 将其视为包含 #!/bin/sh 起始行的文件来处理



#### 文件描述符与 exec()

- 由 exec() 调用打开的所有文件描述符在exec 执行过程中会保持打开，且在新程序中依然有效

- 调用程序可能会以特定的描述符来打开文件，而新程序中的这些文件将自动有效，无需再重新打开

- ```bash
  ls /lmp >dir.txt
  ```

- shell 运行该命令，执行步骤

  1. 调用 fork 创建子进程，子进程会运行 shell 的一份拷贝，包括命令行

  2. 子 shell 以 描述符 1 打开文件 dir.txt 用于输出，方式为以下任一

     - 子 shell 关闭描述符 1 后，随即打开文件 dir.txt 。open 为描述符取值时总是取最小值，而标准输入 0 又仍处于打开状态。

     - shell 打开dir.txt ， 获取一个新的文件描述符。若该文件描述符不是标准输出 1，则shell会使用 dup2() 强制将标准输出复制为新描述符的副本，并将此时已然无用的新描述符关闭（更安全）

       - 源代码

       - ```c
         fd = open("dir.txt", O_WRONLY | O_CREAT,
                  S_IRUSR | SIWUSR | S_IRGRP | S_IWGRP |
                  S_IROTH | S_IWOTH ); // rw-rw-rw-
         if(fd != STDOUT_FILENO){
             dup2(fd, STDOUT_FILENO);
             close(fd);
         }
         ```

  3. 子 shell 执行程序 ls，将其结果输出到标准输出，即 dir.txt

  - 实际情况可能不大相同
  - 某些命令是 shell 内建命令， 由 shel 直接运行，并未调用 fork exec，在针对这些命令必须进行特殊处理
  - shell 内建命令优点
    - 效率
    - 对 shell 产生作用，如 更改 shell 所存储的信息，修改shell进程的属性，影响 shell 的运行
  - shell 内建命令包括但不限于
    - cd exec exit read set source ulimit umask wait job-control jobs fg bg
    - 全套内建命令参考 shell 手册 man bash  SHELL BUILTIN COMMANDS

- 执行时关闭（ close-on-exec ）标志（FD_CLOEXEC）

  - 执行 exec 前，程序有时需要确保关闭某些特定的文件描述符

  - 尤其是特权进程中调用 exec 启动一个 未知程序，或是启动程序不需要使用这些已打开的文件描述符时

  - 为了安全，应在加载新程序之前确保关闭那些不必要的文件描述符

  - 使用close 即可，但存在局限性

    - 某些描述符是由库函数打开的，库函数无法使主程序在 执行 exec 之前关闭相应的文件描述符，因而，库函数总是为其打开的文件设置执行时关闭标志
    - 若 exec 调用失败，可能还需要使描述符保持打开状态

  - 为此，内核为每个文件描述符提供了执行时关闭标志

    - 在成功执行 exec 时，会自动关闭该文件描述符，若调用 exec 失败，文件描述符保持打开

  - 可用 fcntl() F_GETFD 获取文件描述符标志的一份拷贝，获取后对 FD_CLOEXEC 进行修改，再用 fcntl() F_SETFD 使其生效

  - ```c
    int flags;
    
    flags = fcntl(fd, F_GETFD);
    if(flags == -1)
        errExit("fcntl");
    
    flags |= FD_CLOEXEC;
    if(fcntl(fd, F_SETFD, flags) == -1)
        errExit("fcntl");
    ```

  - FD_CLOEXEC 是文件描述符标志中唯一可以操作的一位

  - 包括Linux在内的许多 UNIX ，还允许另外 两种非标准 ioctl() 调用来修改执行时关闭标志

    - 以 ioctl(fd, FIOCLEX) 为 fd 设置此标志
    - 以 ioctl(fd, FIONCLEX) 来清楚此标志

  - 当使用 dup() dup2 fcntl() 为某 fd 创建副本时，总会清楚副本的执行时关闭标志



#### 信号与 exec()

- 



#### system() 执行 shell 命令

- 程序可以通过 调用 system() 来执行任意 shell 命令

- ```c
  #include<stdlib.h>
  
  int system(const char *command);
  ```

- system() 创建一个子进程来运行 shell ，并执行命令 command

- ```c
  system("ls | wc");
  ```

- 主要优点

  - 无需处理对 fork exec wait exit 的调用细节
  - system 会代为处理错误和信号
  - system 使用 shell 来执行 command，在执行 command 之前对其进行所有的常规 shell 处理、替换、重定向

- 缺点——低效率

  - 需要创建至少两个进程
    - shell
    - command，每个命令都会调用一次 exec()

- 返回值

  - command 为 NULL指针时
    - 若 shell 可用则 system() 返回 非 0 值
    - 若不可用 则 返回 0
    - 若运行在非 UNIX 上，系统可能没有shell
    - 所有 UNIX 都有 shell，如果调用 system 之前 又调用了 chroot，shell 依然可能无效
  - command 不为 NULL
    - 若无法创建子进程或是无法获取其终止状态，则 返回 -1
    - 若子进程不能执行 shell，返回之与 子shell 调用 _exit(127) 终止一样
    - 若调用都成功，system 会返回执行 command 的子 shell 终止状态，即最后一条命令的退出状态
      - 若命令被信号所杀，大多数shell会以 128 + n 退出，其中 n 为信息斌好
      - 若子shell 被信号所杀，则其终止状态 如 26.1.3 所述
      - 这两种情况，返回之与waitpid 返回的等待状态形式相同，可使用 26.1.3 所述函数来分析返回值，并以printWaitStatus() 函数加以显示

- ```c
  #include <sys/wait.h>
  #include "print_wait_status.h"
  #include "tlpi_hdr.h"
  
  #define MAX_CMD_LEN 200
  
  int
  main(int argc, char *argv[])
  {
      char str[MAX_CMD_LEN];      /* Command to be executed by system() */
      int status;                 /* Status return from system() */
  
      for (;;) {                  /* Read and execute a shell command */
          printf("Command: ");
          fflush(stdout);
          if (fgets(str, MAX_CMD_LEN, stdin) == NULL)
              break;              /* end-of-file */
  
          status = system(str);
          printf("system() returned: status=0x%04x (%d,%d)\n",
                  (unsigned int) status, status >> 8, status & 0xff);
  
          if (status == -1) {
              errExit("system");
          } else {
              if (WIFEXITED(status) && WEXITSTATUS(status) == 127)
                  printf("(Probably) could not invoke shell\n");
              else                /* Shell successfully executed command */
                  printWaitStatus(NULL, status);
          }
      }
  
      exit(EXIT_SUCCESS);
  }
  ```

- ```bash
  [sinow@SiMaj procexec]$ ./t_system 
  Command: whoami
  sinow
  system() returned: status=0x0000 (0,0)
  child exited, status=0
  Command: ls | grep XYZ # Shell terminates with the status of ...
  system() returned: status=0x0100 (1,0)	#last command grep
  child exited, status=1		# found no match, so did an exit(1)
  Command: exit 127
  system() returned: status=0x7f00 (127,0)
  (Probably) could not invoke shell	# Actually, not true in this case
  Command: sleep 100
  ^Z
  [1]+  Stopped                 ./t_system
  [sinow@SiMaj procexec]$ ps | grep sleep
    12925 pts/2    00:00:00 sleep
  [sinow@SiMaj procexec]$ kill 12925
  [sinow@SiMaj procexec]$ fg
  ./t_system
  system() returned: status=0x000f (0,15)
  child killed by signal 15 (Terminated)
  [sinow@SiMaj procexec]$
  ```

- 在 set-user-ID set-group-ID 的程序中避免使用 system()

  - 在此特权模式下运行时，决不能调用 system()
  - shell 对操作的控制有赖于各种环境变量，使用system 会给系统带来安全隐患
  - 为了确保安全，应当直接调用 fork() exec()



#### system() 的实现

- 简化实现

  - 目标 sh -c 可以执行任意命令的字符串

  - ```bash
    sh -c "ls | wc"
    ```

  - 先用 fork 来创建爱你子进程，并对应于上例 sh 命令的参数来调用 execl()

  - ```c
    execl("/bin/sh", "sh", "-c", command, (char *) NULL);
    ```

  - 为了收集system 所创建的子进程状态，还应为指定的子进程 ID 调用 waitpid()

  - 一个缺乏信号处理的 system 实现

  - ```c
    #include <unistd.h>
    #include <sys/wait.h>
    #include <sys/types.h>
    
    int
    system(char *command)
    {
        int status;
        pid_t childPid;
    
        switch (childPid = fork()) {
        case -1: /* Error */
            return -1;
    
        case 0: /* Child */
            execl("/bin/sh", "sh", "-c", command, (char *) NULL);
            _exit(127);                     /* Failed exec */
    
        default: /* Parent */
            if (waitpid(childPid, &status, 0) == -1)
                return -1;
            else
                return status;
        }
    }
    ```

- 在 system() 内部正确处理信号

  - SIGCHLD
  - 假设调用 system 的程序还直接创建了其他子进程，对SIGHLD 的信号处理其。自身也执行了 wait()
    - 此时在子进程退出并产生 SIGCHLD 信号时，在 system() 调用 waitpid() 前，主程序的信号处理程序可能会率先得以执行（收集子进程的状态）
    - 不良后果
      - 调用程序误以为其所茶u你关键的某个子进程终止了
      - system 无法获取其所创建子进程的终止状态
    - 所以，system() 在运行期间必须阻塞 SIGCHLD 信号
  - 此外还要注意 中断 interrupt Ctrl+C 和 退出 quit Ctrl+\\ 所产生的 SIGINT 和 SIGQUIT
    - 为了提高效率，如果 -c 是一条简单命令，比 管道、序列 简单，则 一些shell 会直接执行该命令，不会创建子shell
    - 在输入中断或退出符时，会将相应符号发给所有的3个进程
      - shell 在等待进程间会忽略 SIGINT SIGQUIT 信号，
      - 默认情况下，会杀死调用程序与sleep进程
        - SUSv3 规定
        - 调用进程在执行命令期间应忽略 SIGINT 和 SIGQUIT 信号
        - 子进程将对已处理的信号重置为默认值，而对其他信号处置保持不变
      - SUSv3 要求按照上述方式来处理 SIGINT SIGQUIT
        - 对于暗中调用 system() 来执行任务的程序，这一做法可能会产生不良后果
        - 执行命令时若 按下 Ctrl+C 或 Ctrl+ \\ ，将只会杀掉 system 子进程，而应用程序会继续运行（用户应该是想结束运行）。
        - 以此方式调用 system 的程序应当检查 system 所返回的终止状态，一旦发现命令因信号而终止，应采取相应措施
  - ![](https://i.loli.net/2021/10/12/K7IQNiShvJsFDEO.jpg)



- 改进版

  - 尝试运行shell

    - 递归调用 system() 去运行 shell 命令 ":" ，并检查返回状态是否为 0
    - “:” 是一个shell 内建命令，不做任何事，总是返回成功（exit(0) 也有相同的效果）
    - 仅通过 access() 来判断 /bin/sh 的存在与否，是否有可执行权限的做法有局限性
      - 在 chroot() 环境中，即便具有可执行权限的shell文件存在，如果其进行动态链接的共享库无效，依然无法执行 shell
    - 只有system调用者才需要阻塞 SIGCHLD，同时忽略 SIGINT SIGQUIT ，不过必须调用 fork之前执行这些动作，因为如果在调用者 fork()  之后执行，将会出现竞争条件，即父进程在阻塞 SIGCHLD 之前，子进程就退出了
    - 父进程并未对 sigaction() sigprocmask() 调用进行错误检查，两者分别用于对信号的处置和信号掩码

  - SUSv3 仅仅提出在创建子进程失败或无法获取子进程状态时，system 返回 -1，并未提及 system 在处理信号失败时也会返回 -1

  - 子进程对于信号相关的系统调用也未执行错误检查

    - 一方面，无法报告此类错误(_exit(127) 是预留给执行shell 时报告错误之用)
    - 另一方面，这一失败不会影响 system 调用者，二者分属不同进程

  - 子进程刚从 fork 返回时，会对 SIGINT 和 SIGQUIT的处置置为 SIG_IGN（继承自父进程），不过，子进程处理这些信号时，如同system 调用者执行了 fork exec，fork 不会改变 子进程 对这些信号的处理方式，而exec 则会将对已处理信号的处置重置为 默认值，但不改变对其他信号的处置。

    - 若调用者对 SIGINT 和 SIGQUIT 的处置设置并非 SIG_IGN ，则子进程会将其置为 SIG_DFL

  -  一些 system 实现反而会将子进程对 SIGINT 和 SIGQUIT 的处置重置为在调用者中生效的设置

    - 这一做法的依据是，后续 execl() 调用 会自动将对这些已处理信号的处置重置为默认值。
    - 但是，这种情况下，若调用 execl 之前的瞬间有信号送达 子进程，则在信号经由 sigprocmask() 解除阻塞后，子进程还是会调用信号处理程序

  - 子进程如果调用 execl 失败， 会以 _exit() 终止进程，这是味儿了防止子进程stdio 缓冲区中的任何为写入数据进行刷新

  - 父进程必须用 waitpid() 来专候其所创建的特定子进程

    - system 的实现未强制使用 信号处理程序，但调用程序可能还是会去创建他们，从而终端对 waitpid() 的阻塞调用
    - SUSv3 明确要求在这种情况下必须重新等待
      - 所以如果发生 EINTR 错误，则循环调用 waitpid 以期成功重启
      - 如果是其他错误，则退出 waitpid 循环

  - ```c
    #include <unistd.h>
    #include <signal.h>
    #include <sys/wait.h>
    #include <sys/types.h>
    #include <errno.h>
    
    int
    system(const char *command)
    {
        sigset_t blockMask, origMask;
        struct sigaction saIgnore, saOrigQuit, saOrigInt, saDefault;
        pid_t childPid;
        int status, savedErrno;
    
        if (command == NULL)                /* Is a shell available? */
            return system(":") == 0;
    
        sigemptyset(&blockMask);            /* Block SIGCHLD */
        sigaddset(&blockMask, SIGCHLD);
        sigprocmask(SIG_BLOCK, &blockMask, &origMask);
    
        saIgnore.sa_handler = SIG_IGN;      /* Ignore SIGINT and SIGQUIT */
        saIgnore.sa_flags = 0;
        sigemptyset(&saIgnore.sa_mask);
        sigaction(SIGINT, &saIgnore, &saOrigInt);
        sigaction(SIGQUIT, &saIgnore, &saOrigQuit);
    
        switch (childPid = fork()) {
        case -1: /* fork() failed */
            status = -1;
            break;          /* Carry on to reset signal attributes */
    
        case 0: /* Child: exec command */
            saDefault.sa_handler = SIG_DFL;
            saDefault.sa_flags = 0;
            sigemptyset(&saDefault.sa_mask);
    
            if (saOrigInt.sa_handler != SIG_IGN)
                sigaction(SIGINT, &saDefault, NULL);
            if (saOrigQuit.sa_handler != SIG_IGN)
                sigaction(SIGQUIT, &saDefault, NULL);
    
            sigprocmask(SIG_SETMASK, &origMask, NULL);
    
            execl("/bin/sh", "sh", "-c", command, (char *) NULL);
            _exit(127);                     /* We could not exec the shell */
    
        default: /* Parent: wait for our child to terminate */
            while (waitpid(childPid, &status, 0) == -1) {
                if (errno != EINTR) {       /* Error other than EINTR */
                    status = -1;
                    break;                  /* So exit loop */
                }
            }
            break;
        }
    
        /* Unblock SIGCHLD, restore dispositions of SIGINT and SIGQUIT */
    
        savedErrno = errno;                 /* The following may change 'errno' */
    
        sigprocmask(SIG_SETMASK, &origMask, NULL);
        sigaction(SIGINT, &saOrigInt, NULL);
        sigaction(SIGQUIT, &saOrigQuit, NULL);
    
        errno = savedErrno;
    
        return status;
    }
    ```

  - 更多细节

    - 为了可移植性，应确保在将对 SIGCHLD 的处置置为 SIG_IGN 的情况下不去调用 system()，此时waitpid 无法获取子进程的状态，因忽略SIGCHLD会导致立即丢弃子进程状态

    - 在一些 UNIX 实现中， 如果在将对 SIGCHLD 的处置置为 SIG_IGN 的情况下调用 system()，system 的应对策略是

      - 临时将其改为 SIG_EFL
      - 只要在把 SIGCHLD 的处置重置为 SIG_IGN 时，UNIX 等能够处理僵尸子进程（Linux 不可以），这种方法便为可行的。若不能做到这一点，此类实现方式会产生不良后果：调用者执行 system 期间，如果另一子进程终止了，则该子进程将成为僵尸进程，且无法回收

    - 在一些 UNIX 实现（尤其是 Solaris）中，/bin/sh 并非标准的 POSIX shell，若希望确保执行 标准 shell，则必须使用库函数 confstr() 来获取配置变量 _CS_PATH 的值。

      - 该值的结构与 PATH 相同，包含了标准系统工具的目录列表。

      - 可将此列表赋给变量PATH，随即调用 execlp() 来执行标准 shell

      - ```c
        char path[PATH_MAX];
        if (confstr(_CS_PATH, PATH_MAX) == 0)
            _exit(127);
        if (setenv("PATH", path, 1) == -1)
            _exit(127);
        execlp("sh","sh","-c",command, (char *) NULL);
        _exit(127);
        ```

      - 

