## 基本概念

- 信号 是时间发生时对进程的通知机制，也称 软件中断

  - 无法预测信号到达的精确时间

- 信号使用

  - A进程到B进程（一种同步技术，进程间通信IPC的原始形式）
  - A进程到A进程
  - 内核到进程（通常都是）
    - 硬件发生异常
      - 执行一条异常的机器语言指令
    - 用户键入产生信号的终端特殊字符
      - 中断Ctrl+C、暂停Ctrl+Z
    - 发生了软件事件
      - 针对文件描述符的输出变为有效
      - 调整终端窗口大小
      - 定时器到期
      - 进程CPU执行时间超过限制
      - 进程的某个子进程退出

- 每个信号都定义了一个唯一的小整数，从1开始顺序展开

  - `<signal.h>` 中对这些整数做了定义
  - 不同系统的实际编号可能不同

- 信号分类

  - 内核向进程通知事件，即传统或标准信号
    - Linux 中标准信号的编号范围为 1~31
  - 实时信号构成，与标准信号差异查看 信号高级特性

- 等待状态

  - 信号产生和到达期间，处于 等待 pending 状态
  - 信号产生后，会于稍后被传递给某一进程，进程会采取某些措施来响应信号

- 一旦内核要调度某进程运行，等待信号会马上送达，或者如果进程正在运行，则会立即传递信号（如进程向自身发送信号）

  - 有时需要确保一段代码不为传递来的信号所终端
    - 为此，可将信号添加到进程的信号掩码中，暂时阻塞该组信号的到达
    - 若产生的信号在阻塞中，则信号将保持等待状态，直至稍后对其解除阻塞，即从信号掩码中移除
    - 进程可以使用各种系统调用对其信号掩码添加和移除信号

- 信号到达后的默认操作

  - 忽略信号
  - 终止（杀死）进程
    - 有时是 进程异常终止，而不是调用 exit 的正常终止
  - 产生核心转储文件，终止进程
    - 核心转储文件包含对进程虚拟内存的镜像，可将其加载到调试器中检查进程终止时的状态
  - 停止进程，暂停
  - 于之前暂停后再度恢复进程的执行

- 对信号的处置 disposition 设置（程序可一改变程序到达的响应行为）

  - 采取默认行为
    - 适用于撤销之前对信号处置的修改、恢复其默认处置的场景
  - 忽略信号
    - 适用于默认行为是终止进程的信号
  - 执行信号处理程序
    - 函数，用于响应传递来的信号而执行适当的任务
    - 如 shell 的SIGINT 信号提供的1处理器程序，令其停止当前正在执行的工作，并将控制返回到 shell 的主输入循环，并再次向用户呈现shell提示符
    - 安装/建立信号处理器程序：通知内核去调用某一处理器程序
      - 用信号处理器程序响应传来的信号，称为信号已处理 handled 或已捕获 caught
      - 无法将信号处置设置为终止进程或转储核心（除非是信号的默认处置）
        - 效果近似：安装处理器程序，调用 exit（类似终止） 或 abort（类似核心转储并终止）
          - 其中abort 为进程产生一个 SIGABRT 信号，并将引发进程转储核心文件并终止

- Linux /proc/PID/status 中包含各种位掩码字段

  - 位掩码以十六进制数显示，最低有效位 代表信号 1，相邻左边一位 代表信号 2

  - | 信号掩码位 | 说明               |
    | ---------- | ------------------ |
    | SigPnd     | 基于线程的等待信号 |
    | ShdPnd     | 进程级等待信号     |
    | SigBlk     | 阻塞信号           |
    | SigIgn     | 忽略信号           |
    | SigCgt     | 捕获信号           |
    | ...        |                    |



### 信号类型与默认行为

| 信号      | 信号值                 | 描述                  | SUSv3 | 默认   |
| --------- | ---------------------- | --------------------- | ----- | ------ |
| SIGABRT   | 6                      | 中止进程              | T     | CORE   |
| SIGALRM   | 14                     | 实时定时器过期        | T     | TERM   |
| SIGBUS    | 7 (SAMP=10)            | 内存访问错误          | T     | CORE   |
| SIGCHLD   | 17 (SA=20, MP=18)      | 终止或停止子进程      | T     | IGNORE |
| SIGCONT   | 18 (SA=19, M=25, P=26) | 若停止则继续          | T     | CONT   |
| SIGEMT    | undef (SAMP=7)         | 硬件错误              |       | TERM   |
| SIGFPE    | 8                      | 算术异常              | T     | CORE   |
| SIGHUP    | 1                      | 挂起                  | T     | TERM   |
| SIGILL    | 4                      | 非法指令              | T     | CORE   |
| SIGINT    | 2                      | 终端中断              | T     | TERM   |
| SIGIO     | 29 (SA=23, MP=22)      | I/O 时可能产生        | T     | TERM   |
| SIGPOLL   |                        |                       |       |        |
| SIGKILL   | 9                      | 确保杀死              | T     | TERM   |
| SIGPIPE   | 13                     | 管道断开              | T     | TERM   |
| SIGPROF   | 27 (M=20, P=21)        | 性能分析定时器过期    | T     | TERM   |
| SIGPWR    | 30 (SA=29, MP=19)      | 电量将耗尽            |       | TERM   |
| SIGQUIT   | 3                      | 终端退出 Ctrl + \     | T     | CORE   |
| SIGSEGV   | 11                     | 无效内存引用          | T     | CORE   |
| SIGSTKFLT | 16 (SAM=undef, P=36)   | 协处理器栈错误        |       | TERM   |
| SIGSTOP   | 19 (SA=17, M=23, P=24) | 确保停止              | T     | STOP   |
| SIGSYS    | 31 (SAMP=12)           | 无效的系统调用        | T     | CORE   |
| SIGTERM   | 15                     | 终止进程              | T     | TERM   |
| SIGTRAP   | 5                      | 跟踪/断点陷阱         | T     | CORE   |
| SIGTSTP   | 20 (SA=18, M=24, P=25) | 终端停止              | T     | STOP   |
| SIGTTIN   | 21 (M=26, P=27)        | BG 后台进程组从终端读 | T     | STOP   |
| SIGTTOU   | 22 (M=27, P=28)        | BG 后台进程组向终端写 | T     | STOP   |
| SIGURG    | 23 (SA=16, M=21, P=29) | 套接字紧急数据        | T     | IGNORE |
| SIGUSR1   | 10 (SA=30, MP=16)      | 用户自定义信号 1      | T     | TERM   |
| SIGUSR2   | 12 (SA=31, MP=17)      | 用户自定义信号 2      | T     | TERM   |
| SIGVTALRM | 26 (M=28, P=20)        | 虚拟定时器过期        | T     | TERM   |
| SIGWINCH  | 28 (M=20, P=23)        | 终端窗口尺寸变化      |       | IGNORE |
| SIGXCPU   | 24 (M=30, P=33)        | 突破对CPU时间的限制   | T     | CORE   |
| SIGXFSZ   | 25 (M=31, P=34)        | 突破对文件大小的限制  | T     | CORE   |

- 对于 SIGXCPU SIGXFSZ SIGSYS SIGBUS 
  - Linux 2.2 默认终止进程，但不会产生核心转储文件
  - Linux 2.4 以后，终止进程并产生核心转储文件
  - 其他 UNIX ，SIGXCPU SIGXFSZ 处理方法与 Linux 2.2 相同
- 其他 UNIX 中，对SIGPWR 默认行为是忽略
- 几个 UNIX，尤其是BSD衍生系统，默认忽略 SIGIO
- SIGEMT 无任何标准接纳，但大多数UNIX都支持
  - 其他UNIX 中，SIGEMT 终止进程并产生核心转储文件





## signal() 改变信号处置

- UNIX 提供了两种方法来改变信号处置：`signal()` `sigaction()`

- signal 系统调用是设置信号处置的原始 API，接口比sigaction 简单，功能少

- 不同UNIX 的signal实现不同，可移植性差， sigaction 是建立信号处理器的首选 API

- signal 是基于 sigaction 系统调用的 glibc 库

- ```c
  #include<signal.h>
  
  void ( *signal(int sig, void(*handler)(int)) )(int);
  ```

- 成功返回先前的信号处置

  - 有可能是先前安装的处理器函数地址，也可能是常量 SIG_DFL SIG_IGN 之一

- 失败返回 SIG_ERR

- 参数 sig

  - 标识希望修改处置的信号编号

- 参数 handler

  - 标识信号抵达时所调用函数的地址

  - handler 函数无返回值，接受一个参数

  - ```c
    void handler(int sig)
    {
        /* Code for the handler */
    }
    ```

  - 

- signal 返回值 是之前的信号处置，一个指针指向带有一个整型参数且无返回值的函数

- 建立一个处理器函数，然后再将信号处置重置为其原来状态

  - ```c
    void (*oldHandler)(int);
    
    oldHandler = signal(SIGINT, newHandler);
    
    if(oldHandler == SIG_ERR)
        errExit("signal");
    
    /* During this time, if SIGINT is delivered, newHandler will be used to handle the signal*/
    
    
    if (signal(SIGINT, oldHandler) == SIG_ERR)
        errExit("signal");
    ```

  - 在不改变信号处置的同时，获取当前信号处置

    - 需要用 sigaction，signal 不可以

- 对信号处理器函数指针做如下类型定义，有助于理解 signal 原型

  - ```c
    typedef void (*sighandler_t)(int);
    
    sighandler_t signal(int sig, sighandler_t handler);
    ```

  - 若定义了 `_GNU_SOURCE` 特性测试宏，则 glibc 将在 `<signal.h>` 的头文件中暴露非标准的 sighandler_t 数据类型

- 在指定 handler 参数时，可用如下值代替函数地址

- | 参数    | 说明                                                         |
  | ------- | ------------------------------------------------------------ |
  | SIG_DFL | 将 信号处置 重置为默认值，适用于将之前signal 调用所改变的信号处置还原 |
  | SIG_IGN | 忽略该信号                                                   |



## 信号处理器简介

- 信号处理程序（信号捕捉器）是 当指定信号传递给进程时将调用的一个函数

- 信号处理器程序应 力求简单

- 信号到达并执行处理器程序

  - ![](https://i.loli.net/2021/10/12/vs5SLVMfjqlT4PC.jpg)
  - 调用信号处理程序，可能随时打断主程序流程
  - 内核代表进程来调用处理程序
  - 当处理器返回时，主程序会在打断的位置恢复执行

- ```c
  #include <signal.h>
  #include "tlpi_hdr.h"
  
  static void
  sigHandler(int sig)
  {
      printf("Ouch!\n");                  /* UNSAFE (see Section 21.1.2) */
  }
  
  int
  main(int argc, char *argv[])
  {
      int j;
  
      if (signal(SIGINT, sigHandler) == SIG_ERR)
          errExit("signal");
  
      for (j = 0; ; j++) {
          printf("%d\n", j);
          sleep(3);                       /* Loop slowly... */
      }
  }
  ```

- ```bash
  [sinow@SiMaj signals]$ ./ouch 
  0
  ^COuch!
  1
  2
  ^COuch!
  3
  ^\Quit (core dumped) # Ctrl + \
  ```

- 内核在调用信号处理器程序时，会引发调用信号编号作为一个整型参数传递给处理器函数，即 sig 参数，当安装相同的处理器来捕获不同类型的信号，可利用 sig 参数来判定引发对处理器调用的是何种信号

- ```c
  #include <signal.h>
  #include "tlpi_hdr.h"
  
  static void
  sigHandler(int sig)
  {
      static int count = 0;
  
      /* UNSAFE: This handler uses non-async-signal-safe functions
         (printf(), exit(); see Section 21.1.2) */
  
      if (sig == SIGINT) {
          count++;
          printf("Caught SIGINT (%d)\n", count);
          return;                 /* Resume execution at point of interruption */
      }
  
      /* Must be SIGQUIT - print a message and terminate the process */
  
      printf("Caught SIGQUIT - that's all folks!\n");
      exit(EXIT_SUCCESS);
  }
  
  int
  main(int argc, char *argv[])
  {
      /* Establish same handler for SIGINT and SIGQUIT */
  
      if (signal(SIGINT, sigHandler) == SIG_ERR)
          errExit("signal");
      if (signal(SIGQUIT, sigHandler) == SIG_ERR)
          errExit("signal");
  
      for (;;)                    /* Loop forever, waiting for signals */
          pause();                /* Block until a signal is caught */
  }
  ```

- ```c
  [sinow@SiMaj signals]$ ./intquit 
  ^CCaught SIGINT (1)
  ^CCaught SIGINT (2)
  ^CCaught SIGINT (3)
  ^\Caught SIGQUIT - that's all folks!
  ```



## kill() 

```c
#include<signal.h>

int kill(pid_t pid, int sig);
```

- 成功返回 0
- 错误返回 -1
- 与 shell 中的 kill 命令类似
- 参数 pid 标识 一个或多个目标进程
  - pid>0 信号发送给指定进程
  - pid=0 信号发送给与调用进程组同组的每个进程，包括自身
  - pid<-1 向组 ID 等于该 pid 绝对值的进程组内所有下属进程发送信号
  - pid=-1 调用进程有权将信号发往的所有目标进程，出去 init 和 自身
    - 若特权级进程发起调用，则会发给系统中所有进程（除了 init 和 自身）
    - 有时称为广播信号
    - SUSv3 未要求将调用进程排除在信号接受范围外，Linux 遵循的是BSD 系统语义
  - 若无进程与pid匹配，则调用失败，并将 errno 置为 ESRCH （查无此进程）
- 参数 sig 指定了要发送的信号
- 进程要将信号发给另一进程，还要有适当权限
  - 特权级（CAP_KILL）进程可向任何进程发送信号
  - 以 root 用户和组运行的 init 进程是特例，仅能接受已安装了处理器函数的信号，可防止意外杀死 init 进程
  - 若发送者的 实际用户ID 或 有效用户ID 匹配于 接受者的 实际用户 ID 或者 保存设置用户 ID (saved set-user-id)，则非特权进程也可向另一进程发送信号
    - 利用此特性，用户可以向由他们启动的 set-user-id 程序发送信号，无需考虑目标进程有效用户ID的当前设置
    - 将目标进程 有效用户 ID 排除在检查范围之外
      - 防止用户A 向 用户B 的进程C 发送信号，而进程C 正在执行的 set-user-ID 程序又属于 用户A
      - SUSv3 要求强制执行如图
      - ![](https://i.loli.net/2021/10/12/429MwXqsNagrRZo.jpg)
  - SIGCONT 信号需要特殊处理
    - 无论用户对 ID 的检查结果如何，非特权进程可以向同一会话中的任一进程发送此信号
    - 利用此规则，运行作业控制的shell可重启已停止的进程组，即使进程已经修改了其用户ID
      - 原理是系统调用改变其凭据，进而成为特权级进程
- 若进程无权发送信号给所请求的pid，则 kill() 将调用失败，errno 置为 EPERM
- 若pid所指的一系列进程（pid 为 负值），可任一可发送信号，则调用成功





## 检查进程的存在

### kill()

- kill() 系统调用可用来检查目标进程是否存在

  -  将参数 sig 指定为 0，即空信号，无信号发送
  - kill() 仅仅会去执行错误检查，查看是否可以向进程发送信号
  - 若失败且 errno 为 ESRCH ，则 目标进程 不存在
  - 若失败且 errno 为 EPERM 或 成功，则进程存在

- 验证一个特定进程 ID 存在 不能保证特定程序仍在运行

  - 内核会随着进程的终止与建立循环使用 ID
  - 特定进程 ID 可能存在，但是 是一个僵尸进程，即进程已死，但无进程尚未执行 wait() 来获取其终止状态

- ```c
  #include <signal.h>
  #include "tlpi_hdr.h"
  
  int
  main(int argc, char *argv[])
  {
      int s, sig;
  
      if (argc != 3 || strcmp(argv[1], "--help") == 0)
          usageErr("%s pid sig-num\n", argv[0]);
  
      sig = getInt(argv[2], 0, "sig-num");
  
      s = kill(getLong(argv[1], 0, "pid"), sig);
  
      if (sig != 0) {
          if (s == -1)
              errExit("kill");
  
      } else {                    /* Null signal: process existence check */
          if (s == 0) {
              printf("Process exists and we can send it a signal\n");
          } else {
              if (errno == EPERM)
                  printf("Process exists, but we don't have "
                         "permission to send it a signal\n");
              else if (errno == ESRCH)
                  printf("Process does not exist\n");
              else
                  errExit("kill");
          }
      }
  
      exit(EXIT_SUCCESS);
  }
  ```

  

### 其他方法

- wait() 系统调用
  - 仅用于监控调用者的子进程
- 信号量和排他文件锁
  - 若进程持续持有某一信号量或文件锁，并且一直处于被监控状态，如果能获取到信号量或锁时，则表明进程已经终止
- 管道和 FIFO 之类的 IPC 通道
  - 可对监控目标进程进行设置，令其在自身生命周期内持有对通道进行写操作的打开文件描述符
  - 令监控进程持有针对通道进行读操作的打开文件描述符，当通道写入端关闭时（遭遇文件结束符），即可获知监控目标进程已经终止
  - 监控进程对此情况的判定
    - 自身文件描述符的读取
    - 描述符监控技术，见 63 章
- /proc/PID 接口
  - 可发起 诸如 stat() 之类的调用
- 除了 /proc/PID 接口，循环使用进程 ID 不会影响上述 3 个方法



## raise() killpg()

- raise() 对自身发送信号

- ```c
  #include<signal.h>
  int raise(int sig);
  ```

- 成功返回 0
- 错误返回 非0
  - 唯一可能发生的错误为 EINVAL，即 sig 无效
    - 不需要检查该函数的返回状态
- 单线程程序中，调用 raise() 相当于 `kill( getpid(), sig )`
- 支持线程的系统会将 raise( sig ) 实现为 `pthread_kill( pthread_self(), sig )` 
  - 将信号传递给调用 raise() 的特定线程， 而 kill( getpid(), sig ) 会发送一个信号给调用进程，并可将该信号传递给该进程的任一线程
- 当进程使用 raise() 向自身发送信号时，信号立即传递，即在 raise 返回 调用者之前



- killpg() 向进程组的所有成员发送一个信号

- ```c
  #include<signal.h>
  
  int killpg(pid_t pgrp, int sig);
  ```

- 成功返回 0

- 错误返回 -1

- 相当于调用 `kill( -pgrp, sig )`

- 若 pgrp 的值为0，则会向调用者所属进程组的所有进程发送此信号

  - SUSv3 未做规范，但大多数 UNIX 于Linux 处理方式相同

## 显示信号描述

- 每个信号都有与之相关的可打印说明，这些描述位于 数组 sys_siglist 中

  - 可用 sys_list[SIGPIPE] 获取对 SIGPIPE 信号断开的描述

  - ```c
    #define _BSD_SOURCE
    #include<signal.h>
    
    extern const char *const sys_siglist[];
    ```

- 更推荐使用 strsignal() 函数

  - ```c
    #define _GNU_SOURCE
    #include<string.h>
    
    char *strsignal(int sig);
    ```

- 返回信号描述 string

- 优势

  - strsignal() 函数对 sig 参数进行 边界检查，然后返回一枚指针，指向针对该信号的可打印描述字符串
    - 在其他一些 UNIX 实现中，strsignal 函数会在 sig 无效时返回空值
  - 对本地 locale 设置敏感，显示信号描述时会使用本地语言

- psignal()

- ```c
  #include<signal.h>
  void psignal(int sig, const char *msg);
  ```

- 在标准错误设备上所示为 msg 参数所给定的字符串，后面跟有一个冒号，随后是对应于 sig 的信号描述

- SUSv3 未规定 psignal() strsignal() sys_siglist ，但有许多 UNIX 实现支持
- SUSv4 加入了 对 psignal() strsignal() 的规范



## 信号集

- 许多信号相关的系统调用都需要能表示一组不同的信号
  - 例如 sigactiono() sigprocmask() 允许程序指定一族将由进程阻塞的信号
- 多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t
- 大多数 UNIX ，包括 Linux ， sigset_t 数据类型是一个 位掩码，但是 SUSv3 对此并无要求，仅要求可以对 sigset_t 类型赋值，使用其他一些类型的结构来表示也可以。



###SUSv3 规定了一系列函数来操纵信号集

#### 初始化信号集

- ```c
  #include<signal.h>
  int sigemptyset(sigset_t *set);
  int sigfillset(sigset_t *set);
  ```

  

- 成功返回 0

- 错误返回 -1

- sigemptyset() 初始化一个未包含任何成员的信号集

- sigfillset() 初始化一个信号集，使其包含所有实时信号

- 必须使用 sigemptyset() 或 sigfillset() 来初始化信号集

  - C 不会对自动变量进行初始化
  - 借助于静态变量初始化为0来表示 空信号集在可移植性上存在问题，因为可能使用位掩码之外的结构来实现信号集



####添加或移除单个信号

- ```c
  #include<signal.h>
  int sigaddset(sigset_t *set, int sig);
  int sigdelset(sigset_t *set, int sig);
  ```

- 成功返回 0 

- 错误返回 -1

- sig 为信号编号



#### sig 是否为信号集 set 的成员

- ```c
  #include<signal.h>
  int sigismember(const sigset_t *set, int sig);
  ```

- 若是返回 1

- 不是返回 0



#### GNU C 库 3个非标准函数

- ```c
  #define _GNU_SOURCE
  #include<signal.h>
  int sigandset(sigset_t *dest, sigset_t *left, sigset_t *right);
  int sigorset(sigset_t *dest, sigset_t *left, sigset_t *right);
  // 成功返回 0
  // 错误返回 -1
  
  
  int sigisemptyset(const sigset_t *set);
  // 若空返回 1
  // 不空返回 0
  ```

- sigandset() 将 left 集 和 right 集的交集置于 dest 集

- sigorset() 将 left 集 和 right 集的并集置于 dest集

- 若 set 未包含信号，则 sigisempty() 返回 true 1



#### 显示信号集测试代码

- printSigset() 显示了指定信号集的成员信号，该函数使用了定义于 <signal.h> 文件的 NSIG 常量，其值等于信号最大编号 加 1
- 获取信号集成员时，会在测试所有信号编号的循环中将该值作为循环上限
- SUSv3 测试代码未定义 NSIG，但大多数 UNIX 的实现都支持这一常量，只是可能需要特定的编译器选项
  - 例如 在Linux中，必须定义如下 功能测试宏 之一 : `BSD_SOURCE` `_SVID_SOURCE` `_GNU_SOURCE`

``` c
#define _GNU_SOURCE
#include <string.h>
#include <signal.h>
#include "signal_functions.h"           /* Declares functions defined here */
#include "tlpi_hdr.h"

/* NOTE: All of the following functions employ fprintf(), which
   is not async-signal-safe (see Section 21.1.2). As such, these
   functions are also not async-signal-safe (i.e., beware of
   indiscriminately calling them from signal handlers). */

void                    /* Print list of signals within a signal set */
printSigset(FILE *of, const char *prefix, const sigset_t *sigset)
{
    int sig, cnt;

    cnt = 0;
    for (sig = 1; sig < NSIG; sig++) {
        if (sigismember(sigset, sig)) {
            cnt++;
            fprintf(of, "%s%d (%s)\n", prefix, sig, strsignal(sig));
        }
    }

    if (cnt == 0)
        fprintf(of, "%s<empty signal set>\n", prefix);
}

int                     /* Print mask of blocked signals for this process */
printSigMask(FILE *of, const char *msg)
{
    sigset_t currMask;

    if (msg != NULL)
        fprintf(of, "%s", msg);

    if (sigprocmask(SIG_BLOCK, NULL, &currMask) == -1)
        return -1;

    printSigset(of, "\t\t", &currMask);

    return 0;
}

int                     /* Print signals currently pending for this process */
printPendingSigs(FILE *of, const char *msg)
{
    sigset_t pendingSigs;

    if (msg != NULL)
        fprintf(of, "%s", msg);

    if (sigpending(&pendingSigs) == -1)
        return -1;

    printSigset(of, "\t\t", &pendingSigs);

    return 0;
}
```



## 信号掩码 （ 阻塞信号传递 ）

- 内核会为每个进程维护一个信号掩码，即一组信号，并将阻塞其针对该进程的传递

- 如果将遭阻塞的信号发送给某进程，那么该信号的传递将延后，直至从进程信号掩码中移除该信号，从而接触阻塞为止
- 向信号掩码中添加一个信号
  1. 当调用信号处理程序时，可将引发调用的信号自动添加到信号掩码中（根据 sigaction() 在安装信号处理器程序时所使用的标志决定）
  2. 使用 sigaction() 建立信号处理器程序时，可以指定一组额外信号，当调用该处理器程序时会将其阻塞
  3. 使用 sigprocmask() 系统调用，随时可以显式向信号掩码中添加或移除信号

### sigprocmask()

```c
#include<signal.h>
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

- 成功返回 0

- 错误返回 -1

- 可修改信号掩码、获取现有掩码

- 参数 how 指定了动作

- | 信号        | 说明                                                         |
  | ----------- | ------------------------------------------------------------ |
  | SIG_BLOCK   | 将 set 指向信号集内的指定信号添加到信号掩码中，即将信号掩码设置为当前值和 set 的并集 |
  | SIG_UNBLOCK | 将 set 指向信号集中的信号从掩码中移除，即使要接触阻塞的信号当前并未阻塞，也不会返回错误 |
  | SIG_SETMASK | 将 set 指向的信号集赋给信号掩码                              |

- 参数 oldset 不空，则其指向一个 sigset_t 结构缓冲区，用于返回之前的信号掩码

- 如果想获取信号掩码而又不对其不作改动，那么可将 set 参数指定为空，这时将忽略 how 参数

- 若要暂时阻止信号的传递，可以使用下例一系列调用来阻塞信号，然后再将信号掩码重置为先前的状态以解除对信号的锁定

- ```c
  sigset_t blockSet, prevMask;
  /* Initialize a signal set to contain SIGINT */
  
  sigempty(&blockSet);
  sigaddset(&blockSet, SIGINT);
  
  /* Block SIGINT, save previous signal mask */
  
  if(sigprocmask(SIG_BLOCK, &blockSet, &prevMask) == -1)
      errExit("sigprocmask1");
  
  /* ... Code that should not be interrupted by SIGINT ... */
  
  /* Restore previous signal mask, unblocking SIGINT */
  
  if(sigprocmask(SIG_SETMASK, &prevMask, NULL) ==-1)
      errExit("sigprocmask2");
  ```

- SUSv3 规定，如果有任何等待信号因对 sigprocmask() 的调用而解除了锁定，那么在此调用返回前至少会传递一个信号；即 如果解除了对某个等待信号的锁定，那么会立即将该信号传递给进程

- 系统将忽略试图阻塞 SIGKILL 和 SIGSTOP 的请求

  - 若试图阻塞，sigprocmask() 不会予以关注，也不会产生错误

  - 可用下列代码来阻塞 除 SIGKILL 和 SIGSTOP 之外的所有信号

  - ```c
    sigfillset(&blockSet);
    if(sigprocmask(SIG_BLOCK, &blockSet, NULL) == -1)
        errExit("sigprocmask");
    ```



## 处于等待状态的信号

- 某个进程接受了一个该进程正在阻塞的信号，会将该信号添加到进程的等待集中。当解除该信号的锁定后，会随之将信号传递给此进程

- sigpending() 可确定进程等待状态的是哪些信号

- ```c
  #include<signal.h>
  int sigpending(sigset_t *set);
  ```

- 成功返回 0

- 错误返回 -1

- 返回调用进程的处于等待状态的信号集，并将其置于 set 指向的 sigset_t 结构中，随后可以使用 sigismember() 函数来检查 set

- 若修改了对等待信号的处置，则当后来解除对信号的锁定时，将根据新的处置来处理信号

- 应用场景

  - 对信号的处置置为SIG_IGN 或 SIG_DFL(如果信号的默认行为是忽略)，从而阻止传递处于等待状态的信号，因此，会将信号从进程的等待信号集中移除，从而不传递该信号



## 不对信号进行排队处理

- 等待信号集只是一个掩码，仅表明一个信号是否发生，为表明发生次数
- 如果同一个信号在阻塞状态下产生多次，则会将该信号在 等待信号集 中记录，稍后仅传递一次（标准信号与实时信号的差异之一）



### 发送多个信号

- ```c
  #include <signal.h>
  #include "tlpi_hdr.h"
  
  int
  main(int argc, char *argv[])
  {
      int numSigs, sig, j;
      pid_t pid;
  
      if (argc < 4 || strcmp(argv[1], "--help") == 0)
          usageErr("%s pid num-sigs sig-num [sig-num-2]\n", argv[0]);
  
      pid = getLong(argv[1], 0, "PID");
      numSigs = getInt(argv[2], GN_GT_0, "num-sigs");
      sig = getInt(argv[3], 0, "sig-num");
  
      /* Send signals to receiver */
  
      printf("%s: sending signal %d to process %ld %d times\n",
              argv[0], sig, (long) pid, numSigs);
  
      for (j = 0; j < numSigs; j++)
          if (kill(pid, sig) == -1)
              errExit("kill");
  
      /* If a fourth command-line argument was specified, send that signal */
  
      if (argc > 4)
          if (kill(pid, getInt(argv[4], 0, "sig-num-2")) == -1)
              errExit("kill");
  
      printf("%s: exiting\n", argv[0]);
      exit(EXIT_SUCCESS);
  }
  ```

- ```bash
  ./sig_sender PID num-sigs sig-num [sig-num-2]
  ```

- 最多接受 4 个参数

- PID 程序发送信号的目标进程 ID

- num-sigs 发送给目标进程的信号数量

- sig-num 发往目标进程的信号编号

- sig-num-2 若提供了第四个参数，则当程序发送完之前参数所指定的信号之后，将发送该信号的一个实例



### 捕获上例所发送的信号并汇总其统计数

- ```c
  #define _GNU_SOURCE
  #include <signal.h>
  #include "signal_functions.h"           /* Declaration of printSigset() */
  #include "tlpi_hdr.h"
  
  static int sigCnt[NSIG];                /* Counts deliveries of each signal */
  static volatile sig_atomic_t gotSigint = 0;
                                          /* Set nonzero if SIGINT is delivered */
  
  static void
  handler(int sig)
  {
      if (sig == SIGINT)
          gotSigint = 1;
      else
          sigCnt[sig]++;
  }
  
  int
  main(int argc, char *argv[])
  {
      int n, numSecs;
      sigset_t pendingMask, blockingMask, emptyMask;
  
      printf("%s: PID is %ld\n", argv[0], (long) getpid());
  
      for (n = 1; n < NSIG; n++)          /* Same handler for all signals */
          (void) signal(n, handler);      /* Ignore errors */
  
      /* If a sleep time was specified, temporarily block all signals,
         sleep (while another process sends us signals), and then
         display the mask of pending signals and unblock all signals */
  
      if (argc > 1) {
          numSecs = getInt(argv[1], GN_GT_0, NULL);
  
          sigfillset(&blockingMask);
          if (sigprocmask(SIG_SETMASK, &blockingMask, NULL) == -1)
              errExit("sigprocmask");
  
          printf("%s: sleeping for %d seconds\n", argv[0], numSecs);
          sleep(numSecs);
  
          if (sigpending(&pendingMask) == -1)
              errExit("sigpending");
  
          printf("%s: pending signals are: \n", argv[0]);
          printSigset(stdout, "\t\t", &pendingMask);
  
          sigemptyset(&emptyMask);        /* Unblock all signals */
          if (sigprocmask(SIG_SETMASK, &emptyMask, NULL) == -1)
              errExit("sigprocmask");
      }
  
      while (!gotSigint)                  /* Loop until SIGINT caught */
          continue;
  
      for (n = 1; n < NSIG; n++)          /* Display number of signals received */
          if (sigCnt[n] != 0)
              printf("%s: signal %d caught %d time%s\n", argv[0], n,
                      sigCnt[n], (sigCnt[n] == 1) ? "" : "s");
  
      exit(EXIT_SUCCESS);
  }
  ```

- 该程序建立了单个处理器程序来捕获所有信号

  - 对于大多数类型的信号，处理器程序只是简单地使用一个数组来对信号计数
  - 若收到 SIGINT ，则处理器程序将对标志gotSigint 置位，从而使程序退出主循环

- 若提供有一个命令行参数给程序，则程序对所有信号阻塞秒数将由该参数指定，并且在接触阻塞之前会显示待处理的信号集，从而是用户在进程执行下面步骤前向其发送信号

- 程序执行 while 循环来消耗 CPU 时间，直至将 gotSigint 置位

  - pause() sigsuspend() 在等待信号到来期间对 CPU 的使用方式都颇为高效

- 退出 while 循环以后，程序显示对所有接收信号的计数



### 两程序展示

- 目的：展示遭阻塞的信号无论产生多少次，仅会传递一次

- 为接收者指定了一个睡眠间隔，并在醒来之前发送所有信号

- ```bash
  [sinow@SiMaj signals]$ ./sig_receiver: PID is 2582
  ./sig_receiver: sleeping for 15 seconds
  ./sig_receiver: pending signals are: 
  		2 (Interrupt)
  		10 (User defined signal 1)
  ./sig_receiver: signal 10 caught 1 time
  ^C
  [1]+  Done                    ./sig_receiver 15
  
  
  [sinow@SiMaj signals]$ ./sig_sender 2582 1000000 10 2
  ./sig_sender: sending signal 10 to process 2582 1000000 times
  ./sig_sender: exiting
  ```

- 发送 SIGUSER1 SIGINT 信号，在 Linux/x86 中为 10 和 2

- 发送了 100M 次，但仅会传递一次给接收者

- 事实上，即使没有阻塞信号，收到的信号也可能比发送给它的要少得多

- 信号发送速度太快，在内核考虑将执行全调度给接收进程之前，这些信号就已经到达，就会导致多次发送的信号在进程等待信号集中只记录一次



## sigaction() 改变信号处置

- sigaction() 系统调用是设置信号处置的另一选择，可移植性更佳，用法更为复杂，更具灵活性，允许在获取信号处置的同时无需将其改变，可设置各种属性对调用信号处理器程序时的行为施以更加精准的控制

- ```c
  #include<signal.h>
  int sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);
  ```

- 成功返回 0

- 错误返回 -1

- 参数 sig 为想要获取或改变的信号编号，可以是出 SIGKILL、SIGSTOP 之外的任何信号

- 参数 act 是一枚指针，指向描述信号新处置的数据结构

  - 若只对信号的现有处置感兴趣，可以将act 设为 NULL

- 参数 oldact 是用来返回之前信号处置的相关信息

  - 若可置空

- sigaction 部分结构

  - ```c
    struct sigaction{
        void (*sa_handler) (int);	// Address of handler
        sigset_t sa_mask;	// Signals blocked during handler invocation
        int sa_flags;	// Flags controlling handler invocation
        void (*sa_restorer)(void);	// Not for application use
    };
    ```

  - sa_handler 对应于signal() 的 handler 参数，其值为信号处理器函数的地址，

    - 也可是常量 SIG_IGN 或 SIG_DFL，但对 sa_mask sa_flags 字段的处理 无效

  - sa_restore 不适用于应用程序，SUSv3 未规定

    - 仅供内部使用，用意确保当信号处理程序完成后，调用专用的 sigreturen() 系统调用，借此来恢复进程上下文，令进程从信号处理器中断的位置继续执行

  - sa_mask 定义了一组信号，在调用由 sa_handler 所定义的处理器程序时将阻塞该组信号

    - 调用信号处理器程序时，会在调用之前，将该组信号中为处于进程掩码之列的任何信号自动添加到进程掩码中
    - 这些信号将保留在进程掩码中，直至信号处理器函数返回，自动删除这些信号
    - 利用 sa_mask 字段可指定一组信号，不允许它们终端此处理器程序的执行
    - 此外，自动添加这一动作意味着：当正在执行处理器程序时，若同一个信号实例第二次抵达，信号处理器程序将不会递归中断自己
    - 由于不会对遭阻塞的信号进行排队处理，如果处理器程序执行过程中重复产生这些信号中的任何信号，之后对信号的传递是一次性的

  - sa_flags 是一个位掩码，指定用于控制信号处理过程中的各种选项，标志如下

  - | 标志         | 说明                                                         |
    | ------------ | ------------------------------------------------------------ |
    | SA_NOCLDSTOP | 若 sig 为 SIGCHLD 信号，则当因接受某信号而停止或恢复某一子进程时，将不会产生此信号 |
    | SA_NOCLDWAIT | 若 sig 为 SIGCHLD 信号，则子进程终止时不会将其转化为僵尸     |
    | SA_NODEFER   | 捕获该信号时，不会在执行处理器程序时将该信号自动添加到进程掩码中 |
    | SA_ONSTACK   | 针对此信号调用处理器函数时，使用了 sigalstack() 安装的被选栈 |
    | SA_RESETHAND | 捕获该信号时，会在调用处理器函数之前将信号重置为默认值（SIG_DFL），默认情况下，信号处理器函数保持建立状态，直至进一步调用 sigaction() 将其显式接触 |
    | SA_RESTART   | 自动重启由信号处理器程序终端的系统调用                       |
    | SA_SIGINFO   | 调用信号处理器程序时携带了额外出纳书，提供了关于信号的深入信息 |



## pause() 等待信号

```c
#include<unistd.h>
int pause(void);
```

- pause() 暂停进程的执行，直至信号处理器函数中断该调用为止（或一个未处理信号终止进程）
- 处理信号时，遭到中断，总是返回 -1 ， errno 置为 EINTR