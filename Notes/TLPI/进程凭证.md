# 进程凭证

| 用户               | User                | 组                  | Group                |
| ------------------ | ------------------- | ------------------- | -------------------- |
| 实际用户 ID        | real user ID        | 实际组 ID           | real group ID        |
| 有效用户 ID        | effective user ID   | 有效组 ID           | effective group ID   |
| 保存的 set-user-ID | saved set-user-ID   | 保存的 set-group-ID | saved set-group-ID   |
| 文件系统用户 ID    | file-system user ID | 文件系统组 ID       | file-system group ID |
|                    |                     | 辅助组 ID           |                      |

---



## 实际用户 ID 和 实际组 ID

- 两者确定了进程所属的用户和组
- 登录 shell 从 /etc/passwd 读取相应用户密码记录的 三、四字段，置其为 实际用户 ID 、实际组 ID
- 当创建新进程时，将从父进程中继承这些 ID



## 有效用户 ID 和 有效组 ID

- 当进程进行各种系统调用时，将结合 **有效用户 ID** 、**有效组 ID** 、 **辅助组 ID** 一起来确定 授予进程的权限
- 如 进程访问 文件、System V 进程间通信 IPC 等系统资源
- 如 内核使用 有效用户 ID 来决定一个进程能否向另一个进程发送信号
- **有效用户 ID** 为 **0** （ root 为0 ）的进程拥有超级用户的所有权限，又称为 **特权进程 (privileged process)** 
- 某些系统调用只能由特权级进程执行
- 一般 **有效用户 ID** 、 **有效组 ID** 与其相应的 **实际用户 ID** 、**实际组 ID** 相等 ，使其不同的方法有两种
  1. 见 *获取和修改进程凭证*
  2. 执行 set-user-ID set-group-ID 操作



## Set-User-ID 和 Set-Group-ID 程序

- set-use-ID 会将进程的 **有效用户 ID** 置为 可执行文件的 **用户 ID（属主）** ，进而获得权限

- set-group-ID 类似

- 文件的 **用户 ID** 和 **组 ID** 决定了文件的所有权

- 文件还有 两个特别的权限位 set-user-ID 位 和 set-group-ID 位， chmod 命令可以设置这些权限位

- ```bash
  [sinow@SiMaj Downloads]$ su
  Password: 
  [SiMaj Downloads]# ls -l test.sh 
  -rwxr-xr-x 1 sinow sinow 112  5月  7 15:07 test.sh
  [SiMaj Downloads]# chmod u+s test.sh 	# 打开 set-user-ID 位
  [SiMaj Downloads]# ls -l test.sh 
  -rwsr-xr-x 1 sinow sinow 112  5月  7 15:07 test.sh
  [SiMaj Downloads]# chmod g+s test.sh 	# 打开 set-group-ID 位
  [SiMaj Downloads]# ls -l test.sh 
  -rwsr-sr-x 1 sinow sinow 112  5月  7 15:07 test.sh
  ```

- 当运行 set-user-ID 程序时，内核会将进程的 **有效用户 ID** 设置为可执行文件的 **用户 ID（即属主）** 

- 通过这种方法修改进程的 **有效用户 ID** 或 **有效组 ID**，可使得 进程 （执行该程序的用户） 获得其 **属主** 权限

- 如 可执行文件属主为 root ， 且为此程序 设置了 set-user-ID 权限位，则当运行该程序时，进程会取得超级用户权限

- 如 出纳构建一个具有对某文件访问权限的 专用用户（组）ID，再创建一个 set-user-ID （ set-group-ID）程序，将进程 **有效用户（组）ID** 变为这个专用 ID，则无需拥有超级用户权限，即可访问该文件 

- set-user-ID-root 表示 root 用户所拥有的 set-user-ID 程序

- 注意 Linux 中，两个权限位 对 shell 脚本无效

- Linux 经常使用的 set-user-ID 程序有

  - passwd(1)
  - mount(8)
  - umount(8)
  - su(1) 切换用户身份 运行 shell
  - wall(1)，用来向 tty 组下辖（通常所有终端都属于该组）的所有终端写入一条消息

- 若要使得某程序以 root 身份运行，且可被任意用户执行，须设置为 set-user-ID-root

- ```bash
  $ su
  $ chown root check_passwd
  $ chmod u+s check_passwd
  $ exit
  # 现在可以被任意用户以root身份运行该程序
  ```



## 保存 set-user-ID 和 保存 set-group-ID

- 与 **set-user-ID** 和 **set-group-ID** 结合使用
- 当执行程序时，会依次发生如下事件
  1. 若 可执行文件 的 set-user-ID 已开启，则将进程的 **有效用户 ID** 置为 可执行文件的 **属主**；否则，进程的**有效用户 ID** 不变
  2. **保存 set-user-ID** 和 **保存 set-group-ID** 的值由对应的 **有效 ID**（属主 ID ？） 复制而来，无论是否设置了 **set-user-ID** 和 **set-group-ID** 
- 上述事件对 group 类似
- 如：某进程 实际用户 ID 、 有效用户 ID 、 保存 set-user-ID 均为 1000，当其执行了 set-user-ID-root 的程序后，实际用户 ID = 1000、 有效用户 ID = 0 、 保存 set-user-ID = 0 
- 一些系统调用允许将 set-user-ID 程序的 实际用户 ID 、 有效用户 ID 、 保存 set-user-ID 之间切换，针对 group 也有类似的系统调用



## 文件系统用户 ID 和 组 ID

- Linux 中 打开文件、改变文件属主、修改文件权限 等 文件系统操作 相应权限 由 **文件系统用户 ID** 、 **文件系统组 ID** （结合 **辅助组 ID**）决定（不是**有效用户 ID** 、 **有效组 ID** ）
- 通常 **文件系统用户 ID** 和 **文件系统组 ID** 的值 等同于 **有效用户 ID** 和 **有效组 ID**， 进而也等同于相应的 实际用户 ID 和 **实际组 ID ** 
- 只要 **有效用户 ID** 或 **有效组 ID** 发生了变化（系统调用或者 set-user-ID 程序），则其相应的 文件系统 ID 也将随之改变为同一值
- 只有当使用 Linux 特有的 setfsuid() setfdgid() 可以使得 **文件系统 ID** 与相应的 **有效 ID** 不同
- 自内核2.0 起，Linux在信号发送权限方面遵循 SUSv3 强制规定的规则，且这些规则不再涉及目标进程的有效用户 ID，保留文件系统 ID 特性已无必要
- 本书后续部分关于文件权限的检查，以及设置新文件的 属主 时，通常根据进程 **有效ID** 来加以解释

- 即便是 处于 Linux 系统的目的而真地使用了 进程的 文件系统 ID，在实践中，这些标识的存在与否并不会带来显著差别



## 辅助组 ID

- 辅助组 ID 用于 标识进程所属的 若干附加的组
- 新进程从父进程处继承这些 ID
- 登陆 shell 从系统组文件中获取其辅助的组 Ih
- 这些 ID 与 有效 ID 、文件系统 ID 相结合，就能决定 文件、System V IPC 对象 和 其他系统资源的访问权限



## 获取和修改进程凭证

| 接口                      | 非特权进程                                                   | 特权进程                                               | 可移植性               |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------ | ---------------------- |
| setuid(u) setgid(g)       | 将 有效 ID 修改为 当前 实际 ID 或保存设置 ID                 | 将 实际 ID、有效 ID 修改为任一值                       | SUSv3 BSD 有不同语义   |
| seteuid(u) setegid(g)     | 将 有效 ID 修改为 当前 实际 ID 或保存设置 ID                 | 修改有效 ID 为任意值                                   | SUSv3                  |
| setreuid(u) setregid(g)   | 独立 将 实际 ID 修改为当前 实际 ID 或 有效 ID 值，将有效ID 修改为当前 实际 ID、有效ID 或 保存设置 ID | 独立 将 实际 ID 和 有效 ID 修改为 任意值               | SUSv3 不同 OS 实现不同 |
| setresuid(u) setresgid(g) | 独立 将 实际 ID、有效 ID 和 保存设置 ID 修改为 当前 实际 ID、有效 ID 或 保存设置 ID | 独立 将 实际 ID 、有效 ID 和 保存设置 ID 修改为 任意值 | 少见于其他 UNIX        |
| setfsuid(u) setfsgid(g)   | 将 文件系统 ID 修改为当前 实际 ID、有效 ID 、文件系统 ID 或者 保存设置 ID | 将文件系统 ID 修改为 任意值                            | Linux 特有             |
| setgroups(n, 1)           | 非特权进程无法调用                                           | 设置辅助组 ID 为 任意值                                | 获得所有 UNIX 支持     |



### 获取、修改 实际、有效、保存设置 标识



#### 获取 实际、有效 ID

```c
#include<unistd.h>

uid_t getuid(void);
// real user

uid_t geteuiud(void);
// effective user

gid_t getgid(void);
// real group

gid_t getegid(void);
// effective group

```

- 这些系统调用总会成功



#### 修改有效 ID

```c
#include<unistd.h>

int setuid(uid_t uid);
int setgid(gid_t gid);
```

- 成功返回 0
- 错误返回 -1

1. 非特权进程调用 setuid() 
   - 仅能修改进程的有效用户 ID
   - 仅能将 有效用户 ID 修改成 相应的 实际用户 ID 或 保存 set-user-ID ，否则会 产生 EPERM 错误
   - 仅当 非特权用户 执行 set-user-ID 程序时，该调用才起作用
     - 由于 实际用户 ID、有效用户 ID、保存 set-user-ID 三者均相等
     - BSD 实现：会修改 实际、有效、保存设置 ID，将其改为当前 实际 或 有效 ID 值

2. 特权进程以非 0 参数调用 setuid()
   - 其 实际用户 ID、有效用户 ID、保存 set-user-ID 均被置为 uid 参数所指定的值
   - 这种操作是 单向的
     - 一旦 特权进程 修改了其 ID，则所有特权 都将消失
     - 若要避免单向性，可使用 seteuid()或 setreuid() 来代替 setuid()

- setgid() 系统调用修改 组 ID 与 上述类似，规则 1 完全一致，规则2 对组 ID 的修改不会引起 进程特权的丢失（拥有特权与否由 有效用户 ID 决定）

- 对 set-user-ID-root 程序，以不可逆方式放弃所有特权的首选方法是

  - ```c
    if(setuid(getuid())==-1)
        errExit("setuid");
    ```

- 如果 set-user-ID 程序的属主 不是root,可使用 setuid() 将 有效用户 ID 在 实际用户 ID 和 保存 set-user-ID 之间来回切换

- 来回切换的效果，同样可以使用 seteuid() 来达成

- ```c
  #include<unistd.h>
  
  int seteuid(uid_t euid);
  int setegid(gid_t egid);
  ```

- 成功返回 0

- 错误返回 -1

1. 非特权级进程

   - 仅能 将其 有效 ID 修改为 相应的 实际 ID 或 保存设置 ID

2. 特权级进程

   - 能够 将其 有效 ID 修改为 任意值

   - 若特权级进程使用 seteuid() 将其 有效用户 ID 修改为 非 0 值，则 此进程将不再具有特权
   - 但是可以通过 规则 1 来恢复

- 对于需要 对特权 收放自如 的 set-user-ID 和 set-group-ID 程序，更推荐 seteuid()

- ```c
  euid = geteuid();
  if(seteuid(getuid())==-1)
      errExit("seteuid");
  
  if(seteuid(euid)==-1)
      errExit
  ```



#### 修改 实际 ID 和 有效 ID

- seteuid() 系统调用允许进程独立修改其 实际 和 有效用户 ID

- ```c
  #include<unistd.h>
  
  int setreuid(uid_t ruid, uid_t euid);
  int setregid(gid_t rgid, gid_t egid);
  ```

- 成功返回 0

- 错误返回 -1

- 参数 1 为 新的 实际 ID，参数 2 为 新的 有效 ID

- 若只想修改其中一个，另外一个参数指定为 -1

1. 非特权进程 

   - 只能 将其 实际用户 ID 设置为 当前 实际用户 ID 值（即保持不变） 或 有效用户 ID 值

   - 只能 将其 有效用户 ID 设置为 当前 实际用户 ID 、有效用户 ID（即保持不变）或 有效用户 ID 值

2. 特权进程

   - 能够将其 实际用户 ID 和 有效用户 ID 设置为 任意值

3. 无论 是否是特权进程，只要如下条件成立，即可将 保存 set-user-ID 设置为 新的 有效用户 ID

   1. ruid 不为 -1
   2. 对 有效用户 ID 所设置的值不同于 系统调用之前的实际用户 ID

   - 如果进程使用 setreuid() 仅将有效用户 ID 修改为 实际用户 ID 的当前值，则保存 set-user-ID 的值 将保持不变，并且后续可调用 setreuid() 或 seteuid() 将有效用户 ID 恢复为 保存 set-user-ID 的值

   - 永久放弃特权的方法

   - ```c
     setreuid(getuid(), getuid());
     ```

- set-user-ID-root 进程 若要将用户凭证和组凭证 改变为 任意值，应首先调用 setregid() ，再 调用 setreuid()
  - 顺序不可颠倒，因为 调用 setreuid() 后，程序不再具有特权



#### 获取 实际、有效、保存设置 ID

- ```c
  #define _GNU_SOURCE
  #include<unistd.h>
  
  int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
  int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);
  ```

- 成功返回 0

- 错误返回 -1

- Linux 提供的两个非标准 系统调用 实现 直接获取 保存设置 ID



#### 修改 实际、有效、保存设置 ID

- ```c
  #define _GNU_SOURCE
  #include<unistd.h>
  
  int setresuid(uid_t ruid, uid_t euid, uid_t suid);
  int setresgid(gid_t rgid, gid_t egid, gid_t sgid);
  ```
  
- 成功返回 0

- 错误返回 -1

- 对不修改的参数值指定为 -1
- 如 `setresuid(-1,x-1);` 等同于 `seteuid(x)`

1. 非特权进程能够将实际用户ID、有效用户ID 和 保存 set-user-ID 中的任一 ID 设置为实际用户 ID、有效用户 ID 或 保存 set-user-ID 之中的任一当前值
2. 特权级进程能够对其实际用户 ID、 有效用户 ID 和 保存 set-user-ID 做任意设置
3. 总是将文件系统用户 ID 设置为与 有效用户 ID 相同

- 两个调用均是 “原子操作” ，对 ID 的修改请求 全部成功 或 全部失败
- SUSv3 未 规范，其他 UNIX 鲜有支持



#### 获取、修改文件系统 ID

- ```c
  #include<sys/fsuid.h>
  
  int setfsuid(uid_t fsuid);
  总是返回 改变前 文件系统用户 ID
  
  int setfsgid(gid_t fsgid);
  ```

- 