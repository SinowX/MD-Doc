# 线程

### 概述

- 线程thread 是允许应用程序并发执行多个任务的一种机制。
- 一个进程可以包含多个线程。
- 同一程序中的所有线程均会独立执行相同程序，共享一份全局内存区域
  - 包括初始化数据段
  - 未初始化数据段
  - 堆内存段
- <img src="https://i.loli.net/2021/10/12/3wJfyjq8hinPxIC.png" style="zoom:50%;" />
- 同一进程中的多个线程可以并发执行，多处理器环境下，多个线程可以同时并行
- 进程的限制
  - 进程间的信息难以共享
    - 除去只读代码段，父子进程并未共享内存，必须采用IPC，在进程间进行信息交换
  - 调用fork() 创建进程的代价相对较高。
    - 即便使用写时复制，仍然要复制包括内存页表（page table）、文件描述表（file descriptor table）之类的多种进程属性
- 线程解决的问题
  - 线程之间能够方便、快速的共享信息。
    - 只需要将数据复制到共享（全局或堆）变量中即可
  - 创建线程比创建进程通常要快10倍或更多。
    - 线程之间本来无需复制内存页、页表等
- 除了全局内存之外，线程还共享了
  - 进程ID、父进程ID
  - 进程组ID、session ID
  - 控制终端
  - 进程凭证（process credential）（用户ID和组ID）
  - 打开的文件描述符
  - 由fcntl() 创建的记录锁 record lock
  - 信号处置
  - 文件系统相关信息
    - 文件权限掩码
    - 当前工作目录
    - 根目录
  - 间隔定时器 settimer() POSIX定时器 timer_create()
  - system V 信号量撤销 undo、semadj 值
  - 资源限制
  - CPU时间消耗 times()
  - 资源消耗 getrusage()
  - nice 值
- 各个线程独有的部分属性
  - 线程 ID thread ID
  - 信号掩码 signal mask
  - 线程特有数据
  - 备选信号栈 sigaltstack()
  - errno 变量
  - 浮点型 floating-point 环境
  - 实时调度策略 real-time scheduling policy、优先级
  - CPU 亲和力 affinity
  - capability
  - 栈，本地变量和函数的调用链接linkage信息
- 所有线程的栈在同一虚拟地址空间，利用指针，各个线程可以在对方栈相互共享数据
  - 由于局部变量的状态有效与否依赖于其所驻留栈帧的生命周期，需要谨慎处理
  - 函数返回时，函数栈帧所占用的内存区域有可能为后续的函数调用重新使用
  - 若线程终止，则新线程有可能会对已终止的栈所占有的内存空间加以利用



---

### Pthread API 标准

#### Pthreads data type

- SUSv3 未规定如何实现这些数据类型
- 可抑制程序应将其视为不透明数据，避免对此类数据类型变量的结构或内容产生任何依赖，尤其是不可用 == 去比较

- | 数据类型            | 描述                                   |
  | ------------------- | -------------------------------------- |
  | pthread_t           | 线程ID                                 |
  | pthread_mutex_t     | 互斥对象 Mutex                         |
  | pthread_mutexattr_t | 互斥属性对象                           |
  | pthread_cond_t      | 条件变量 condition variable            |
  | pthread_condattr_t  | 条件变量的属性对象                     |
  | pthread_key_t       | 线程特有数据的键                       |
  | pthread_once_t      | 一次性初始化控制上下文 control context |
  | pthread_attr_t      | 线程的属性对象                         |



#### 线程 errno

- 在多线程程序中，每个线程都有属于自己的errno
- Linux实现中
  - 将errno定义未一个宏，可展开为函数调用，该函数返回一个可修改的 左值，且为每个线程所独有
- errno 机制在保留传统 UNIX API 报错方式的同时，也适应了多线程环境

#### Pthreads 函数返回值

- 返回0表示成功，返回正值表示失败

- 失败返回值与传统UNIX调用置于errno中的值含义相同

- 由于多线程对errno的每次调用都会带来函数调用的开销，因此，可以使用一个中间变量，自己实现诊断函数

  - ```c++
    pthread_t *thread;
    int s;
    s = pthread_create(&thread,NULL,func,&arg);
    if (s != 0)
        errExitEN(s,"pthread_create");
    ```

#### 编译Pthreads程序

- Linux 编译调用了 Pthreads API 的程序时，要设置 `cc -pthread` 编译选项
  - 定义 _REENTRANT 预处理宏。这个会公开对少数可重入reentrant 函数的声明
  - 程序会与库 libpthread 进行链接，即 `-l pthread`

---



### 创建线程

- 启动程序时，产生的进程只有单条线程，称为初始 initial 或 主 main 线程

- `pthread_create()` 负责创建一条新线程

- ```c++
  #include<pthread.h>
  int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start)(void *), void *arg);
  ```

- 成功返回0

- 失败返回整数

- 新线程通过调用函数 `start(arg)` 开始执行。调用pthread_create() 的线程会继续执行该调用之后的语句

- 将 arg 为 void * 类型，意味着可以将指向任意对象的指针传递给 start 函数

  - 一般情况下，arg指向一个全局变量或堆变量，也可以置为 NULL
  - 如果要传递多个参数，可以指向一个结构
  
- 通过审慎的类型转换，可以通过arg传递int类型的值

  - 大部分编译器允许 int 与 void* 之间相互强制转换
  - 一定要小心谨慎使用
    - 取消线程时的返回值 PTHREAD_CANCELED，通常是由实现所定义的整型值，再强制转换为 void*
    - 若线程A的start函数将此整型值返回给正在执行pthread_join() 的线程B，B会误认为A遭到了取消
    - 如果采用了线程取消技术并选择将start函数的返回值强制转换为整型，那么必须确保线程正常结束时的返回值与当前Pthreads实现中的 PTHREAD_CANCELED 不同
    - 为了可移植性，在任何将要运行该应用的实现中正常退出线程的返回值应不同于相应的PTHREAD_CANCELED值

- 参数thread指向 pthread_t 类型的缓冲区，在 pthread_create() 返回前，会在此保存一个该线程的唯一标识，后续的Pthreads函数将使用该标识来引用此线程

- SUSv3 明确指出，在新线程开始执行之前，实现无需对thread参数所指向的缓冲区进行初始化，即新线程可能会在pthread_create()返回给调用者之前已经开始运行。

- 参数attr是指向 pthread_attr_t 对象的指针，该对象指定了新线程的各种属性，若置NULL，则创建新线程时将使用各种默认属性

- 调用 pthread_create() 后，应用程序无法确定系统接着会调度哪一个线程来使用CPU资源，注意使用同步技术

---

### 终止进程

- 终止线程的方法

  - 线程start 函数执行 return 语句
  - 线程调用 pthread_exit()
  - 调用 pthread_cancel() 取消线程
  - 任意线程调用exit() 或主线程执行了 return()，都会导致进程中所有线程立即终止

- ```c++
  #include<pthread.h>
  void pthread_exit(void *retval);
  ```

- pthread_exit() 相当于在 start 函数中执行 return，不同之处在于，可在线程start函数所调用的任意函数中调用phread_exit()

- 参数retval指定了线程的返回值

  - retval所指向的内容不应分配于线程栈中，因为线程终止后，无法确定线程栈的内容是否有效，同理，也不应在线程栈中分配线程start函数的返回值

- 如果主线程调用了pthread_exit()，而不是exit()或return()语句，则其他线程将继续运行。



---

### 线程ID Thread ID

- 线程ID会返回给pthread_create()调用者，一个线程可以通过 pthread_self() 获取自己的线程ID

- ```c++
  #include<pthread.h>
  pthread_t pthread_self(void);
  ```

- 线程ID作用

  - 不同的 Pthreads 函数 thread ID 标识目标线程
    - pthread_join()、pthread_detach()、pthread_cancel()、pthread_kill()等
    - 在一些应用程序中，以特定线程的 thread ID作为动态数据结构的标签，既可以用来识别某个数据结构的创建者或属主线程，又可以确定随后对该数据结构执行操作的具体线程。

- ```c++
  #include<pthread.h>
  
  int pthread_equal(pthread_t t1,pthread_t t2);
  ```

- 相同返回非0，不同返回0

- ```c++
  if (pthread_equal(tid, pthread_self())
      printf("tid matches self\n");
  ```

- 必须将 pthread_t 作为一种不透明的数据类型加以对待

- Linux 将 pthread_t 定义为 unsigned long，其他实现中，可能是一个指针或结构

  - ```c++
    pthread_t thr;
    printf("Thread ID=%ld\n",(long)thr);
    //在包括 Linux 的许多实现上都可以正常运行，在调试过程中很实用
    ```

- Linux 中，线程 ID 在所有进程中都是唯一的，其他实现不一定

  - SUSv3 特别指出，若使用线程 ID 来标识其他进程的线程，其可移植性无法保证
  - 在对已终止线程施以 pthread_join() 或 在已分离 detached 线程退出后，实现可以复用该线程的线程ID

- POSIX 线程 ID 与 Linux 专有的系统调用 gettid() 所返回的线程 ID 并不相同

  - POSIX 线程ID由 线程库实现来负责分配和维护
  - gettid() 返回的线程ID 是一个由Kernel 分配的数字，类似于pid
  - 虽然在Linux NPTL(Native Posix Thread Library) 线程实现中，每个POSIX都对应一个唯一的内核线程 ID，但程序一般无需了解内核线程ID



---

### 连接 joining 已终止的线程

- 函数 pthread_join() 等待由 thread 标识的线程终止。

- ```c++
  #include<pthread.h>
  int pthread_join(pthread_t thread, void **retval);
  ```

- 成功返回0

- 错误返回正值

- 若retval为非空指针，将会保存线程终止时返回值的拷贝，该返回值亦即线程调用 return 或 pthread_exit() 时所指定的值

- 如向 pthread_join() 传入一个之前已经连接过的线程 ID，将会导致无法预知的行为

  - 相同的线程 ID 在参与一次连接后恰好为另一新建线程所重用，再度连接的可能就是这个新线程

- 若线程未分离，则必须使用 pthread_join() 来进行连接

  - 如果未能连接，那么线程终止时将产生僵尸线程

- pthread_join() 与 针对进程的 waitpid() 调用 类似，不过存在一些显著差别

  - 线程之间的关系是对等的(peers)
    - 进程中任意线程均可以调用pthread_join() 与该进程的任何其他线程连接起来
    - 如果线程 A 创建线程 B，B再创建C。则A可以连接(joining) C，C也可以连接A
  - 无法连接 “任意” 线程，也不能以 nonblocking 方式进行连接，使用 条件变量可以实现类似功能

- ```c++
  #include<pthread.h>
  #include"tlpi_hdr,h"
  
  static void* threadFunc(void *arg)
  {
      char *s = (char *) arg;
      printf("%s\n",s);
      return (void *) strlen(s);
  }
  
  int main(int argc, char *argv[])
  {
      pthread_t t1;
      void *res;
      int s;
      s = thread_create(&t1,NULL,threadFunc,"Hello World");
      if (s!=0)
          errExitEN(s,"pthread_create");
      printf("Message from main()\n");
      s = pthread_join(t1, &res);
      if(s!=0)
          errExitEN(s, "pthread_join");
      
      printf("Thread returned %ld\n",(long) res);
      exit(EXIT_SUCCESS);
  }
  ```



---

### 线程的分离

- 默认情况下，线程是可连接(joinable)的，即当线程退出时，其他线程可以通过调用 pthread_join() 获取其返回状态

- 有时不关心线程返回状态，仅希望在线程终止时能够自动清理并移除，此时

  - 可以调用 pthread_detach() 并向 thread 参数传入指定线程的标识符，将该线程标记为处于分离 (detached) 状态

- ```c++
  #include<pthread.h>
  int pthread_detach(pthread_t thread);
  ```

- 成功返回0

- 错误返回正值

- 线程可以自行分离 pthread_detach(pthread_self())

- 一旦线程处于分离状态，就不能再使用 pthread_join() 来获取其状态，也无法使其重返 “可连接” 状态

- 其他线程调用 exit() 或主线程 return 时，即使分离的线程也还是会受到影响

  - 不管线程可连接状态还是已分离状态，进程的所有线程都会立即终止
  - 即pthread_detach() 仅仅是控制线程终止后所发生的事情，而不是何时、如何终止进程

### 线程VS进程

- 多线程的优点
  - 线程间数据共享方便
  - 创建线程更快
- 多线程缺点
  - 需要确保调用线程安全 thread-safe 的函数，或以线程安全的方式来调用函数，多进程无需关注
  - 某个线程的bug可能会危及该进程的所有线程
  - 每个线程都在争用宿主进程 host process 中有限的虚拟地址空间
  - 多线程应用中处理信号，需要小心设计
