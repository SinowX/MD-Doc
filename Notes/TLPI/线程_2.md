# 线程同步

### 互斥量

- 互斥变量由 `pthread_mutex_t` 类型表示
- 使用互斥变量之前，必须首先对其进行初始化
  - 可以把其设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于静态分配的互斥量）
  - 也可以通过调用 pthread_mutex_init 进行初始化
- 如果动态分配互斥量（如malloc），在释放内存之前需要调用 pthread_mutex_destroy

- ```c
  #include<pthread.h>
  int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
  
  int pthread_mutex_destroy(pthread_mutex_t *mutex);
  ```

  - 若成功，返回0
  - 否则返回错误编号
  - 要使用默认的初始化互斥量，只需要把 attr 设为NULL

- 对互斥量加锁，需要调用 pthread_mutex_lock，若互斥量已经上锁，调用线程将阻塞直到互斥量被解锁

- 对互斥量解锁，需要调用 pthread_mutex_unlock

- ```c
  #include<pthread.h>
  int pthread_mutex_lock(pthread_mutex_t *mutex);
  int pthread_mutex_trylock(pthread_mutex_t *mutex);
  int pthread_mutex_unlock(pthread_mutex_t *mutex);
  ```

  - 若成功，返回0
  - 否则返回错误编号
  - 若不希望被阻塞，可以使用pthread_mutex_trylock 尝试对互斥量加锁
    - 若互斥量已经加锁，则返回 EBUSY

- ```c
  #include<pthread.h>
  #include<time.h>
  int pthread_mutex_timelock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);
  ```

  - 成功返回0
  - 否则返回错误编号

  - 允许绑定线程阻塞时间，超时后返回 ETIMEDOUT
  - timespec 结构用秒和纳秒描述时间，是绝对时间

### 读写锁 reader-writer lock

- 读写锁有3种状态

  - 读模式加锁
  - 写模式加锁
  - 不加锁

- 一次只有一个线程可以占有写模式的读写锁，但多个线程可以同时占有读模式的读写锁

- 读模式加锁

  - 所有以读模式进行加锁的线程都可以得到访问权
  - 所有以写模式进行加锁的线程都会阻塞，直到所有线程释放其读锁为止

- 读写锁也叫共享互斥锁 shared-exclusive lock

- 读写锁在使用前必须初始化，在释放其底层的内存之前必须销毁

- ```c
  #include<pthread.h>
  int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
  int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
  ```

  - 成功返回0
  - 否则返回错误编号

- 读写锁通过调用 pthread_rwlock_init 进行初始化

- 若希望读写锁有默认的属性，可以传一个 null 指针给 attr

- 在释放读写锁占用的内存之前，需要调用 pthread_rwlock_destroy 清理

  - 若 init 分配了资源， destroy 将释放这些资源
  - 若调用 destroy 之前就释放了读写锁占用的 内存空间，则分配给这个锁的资源就会丢失

- 读模式加锁调用 pthread_rwlock_rdlock

- 写模式加锁调用 pthread_rwlock_wrlock

- 解锁都可以调用 pthread_rwlock_unlock

- ```c
  #include<pthread.h>
  int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
  int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
  int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
  ```

  - 成功返回0
  - 否则返回错误编号

- 各种实现可能会对共享模式下可获取的读写锁的次数进行限制，所以需要检查 pthread_rwlock_rdlock 的返回值

- 即使 pthread_rwlock_wrlock 和 pthread_rwlock_unlock 有错误返回，但是如果锁设计合理，就不需要检查

- 错误返回值的定义只是针对不正确使用读写锁的情况，或者视图获取已拥有的锁从而可能产生死锁的情况，但是特定情况下，可能会有另外的错误返回

- ```c
  #include<pthread.h>
  int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
  int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
  ```

  - 成功返回0
  - 否则返回错误编号 EBUSY

- ```c
  #include<pthread.h>
  #include<time.h>
  int pthread_rwlock_timerdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);
  int pthread_rwlock_timewrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);
  ```

  - 超时后返回 ETIMEDOUT

### 条件变量

- 条件变量与互斥量一起使用，允许线程以无竞争的方式等待特定的条件发生

- 条件本身是由互斥量保护的，线程改变条件状态之前必须首先锁住互斥量

- 在使用条件变量之前需要初始化 

- 数据类型 pthread_cond_t

- 可以把常量 PTHREAD_COND_INITIALIZER 赋给静态分配的条件变量

- 如果是动态分配的，需要使用 pthread_cond_init 函数对条件变量初始化

- 在释放条件变量底层内存空间之前，可以使用pthread_cond_destroy 函数对条件变量进行范初始化 deinitialize

- ```c
  #include<pthread.h>
  int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);
  int pthread_cond_destroy(pthread_cond_t *cond);
  ```

  - 成功返回0
  - 否则返回错误编号
  - 若使用默认值，attr可设置为 NULL

- ```c
  #include<pthread.h>
  int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);
  int pthread_cond_timewait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex,const struct timespec *restrict tsptr);
  ```

  - 成功返回0

  - 否则返回错误编号

  - 传递给pthread_cond_wait的互斥量对条件进行保护

    - 调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁
    - 这就关闭了条件检查和进程进入休眠状态等待条件这两个操作之间的时间通道，这样线程就不会错过条件的任何变化
    - pthread_cond_wait 返回时，互斥量再次被锁住

  - 设置 struct timespec 的时间方法

    - clock_gettime()
    - gettimeofday 获取 timeval 结构的当前时间，然后把这个时间转化为 timespec 结构

  - 如果超时到期时条件还是没有出现， pthread_cond_timewait 将重新获取互斥量，然后返回错误 ETIMEDOUT

  - 从 pthread_cond_wait 或者 pthread_cond_timewait 调用成功返回时，线程需要重新计算条件，因为一个线程可能已经在运行并改变了条件

  - ```c
    #include<pthread.h>
    int pthread_cond_signal(pthread_cond_t *cond);
    int pthread_cond_broadcast(pthread_cond_t *cond);
    ```

    - 成功返回0
    - 否则返回错误编号
    - pthread_cond_signal 至少能唤醒一个等待该条件的线程
    - pthread_cond_broadcast 唤醒等待该条件的所有线程
    - 必须注意，一定要在改变条件状态之后再给线程发信号



### 自旋锁

