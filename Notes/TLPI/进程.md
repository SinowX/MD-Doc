### 进程基本概念

- 进程是由内核定义的抽象的实体
- 包含的信息内容
  - 二进制格式标识
    - 用于描述可执行文件格式的元信息（metainformation）
    - 现在Linux采用可执行连接格式 ELF
  - 机器语言指令
    - 对程序算法进行编码
  - 程序入口地址
    - 标识程序开始执行时的其实指令位置
  - 数据
    - 程序文件包含的变量初始值和程序使用的字面常量值（literal constant）
  - 符号表及重定位表
    - 描述程序中函数和变量的位置及名称，包括调试和运行时的符号解析（动态链接）
  - 共享库和动态链接信息
    - 程序文件所包含的一些字段，列出了程序运行时需要的共享库，加载共享库的动态链接器路径名
  - 其他信息
    - 许多其他信息，用以描述如何创建进程
- 从内核角度来看
  - 进程由用户内存空间和一系列内核数据结构组成
  - 用户内存空间包含程序代码及代码所使用的变量
  - 内核数据结构用于维护进程状态信息
    - 标识号 IDs
    - 虚拟内存表
    - 打开文件的描述符表
    - 信号传递及处理的有关信息
    - 进程资源使用及限制
    - 当前工作目录
    - 等大量其他信息



### 进程号

- ```c
  #include<unistd.h>
  pid_t getpid(void);
  ```

- 总是成功返回PID

- Linux内核限制进程号不大于32767

  - 新创建进程的PID由内核按顺序将下一个可用的进程号分配给其使用
  - 每当进程号达到32767的限制时，内核将重置进程号计数器，以从小整数开始分配
  - 每次重置为300，因为低数值进程号为系统进程和守护进程长期占用
  - Linux 2.6 及以后，PID默认上限为32767，可修改/proc/sys/kernel/pid_max 来进行调整
    - 最大进程号+1
    - 32位 最大为32768
    - 64位 最大为2^22

- ```c
  #include<unistd.h>
  pid_t getppid(void);
  ```

- 总是成功返回PPID



### 进程内存布局

- 文本段
  - 包含了进程运行的程序机器语言指令
  - 只读
  - 可共享，一份程序代码的拷贝可以映射到所有的这些进程虚拟地址空间
- 初始化数据段
  - 显式初始化的全局变量、静态变量
  - 程序加载到内存时，从可执行文件中读取这些变量的值

- 未初始化数据段 BSS block started by symbol

  - 包含了未进行显式初始化的全局变量和静态变量
  - 程序启动前，系统将本段所有内存初始化为0
  - 可执行文件只需要记录未初始化数据段的位置及所需大小，直到运行再由程序加载器来分配这一空间

- 栈

  - 动态增长搜索的段
  - 由栈帧组成
  - 系统为每个当前调用的函数分配一个栈帧
  - 栈帧中存储了函数的局部变量、实参和返回值

- 堆

  - 在运行时为变量动态进行内存分配的一块区域
  - 堆顶端称作 program break

- `size`命令可以显示可执行文件的文本段text 、初始化数据段、非初始化数据段BSS 的大小

- ```c
  #define _BSD_SOURCE
  #include <stdio.h>
  #include <stdlib.h>-
  
  char globBuf[65536];            /* Uninitialized data segment */
  int primes[] = { 2, 3, 5, 7 };  /* Initialized data segment */
  
  static int
  square(int x)                   /* Allocated in frame for square() */
  {
      int result;                 /* Allocated in frame for square() */
  
      result = x * x;
      return result;              /* Return value passed via register */
  }
  
  static void
  doCalc(int val)                 /* Allocated in frame for doCalc() */
  {
      printf("The square of %d is %d\n", val, square(val));
  
      if (val < 1000) {
          int t;                  /* Allocated in frame for doCalc() */
  
          t = val * val * val;
          printf("The cube of %d is %d\n", val, t);
      }
  }
  
  int
  main(int argc, char *argv[])    /* Allocated in frame for main() */
  {
      static int key = 9973;      /* Initialized data segment */
      static char mbuf[10240000]; /* Uninitialized data segment */
      char *p;                    /* Allocated in frame for main() */
  
      p = malloc(1024);           /* Points to memory in heap segment */
  
      doCalc(key);
  
      exit(EXIT_SUCCESS);
  }
  ```

- 应用程序二进制接口（ABI）是一套规则，规定了二进制可执行文件运行时应如何与某些服务（内核或函数库所提供的信息）交换信息。ABI特别规定了使用哪些寄存器和栈地址来交换信息以及所交换值的含义，一旦针对某个特定ABI进行了编译，其二进制文件应能在ABI相同的任何系统上运行

- 标准化API（如SUSv3）仅能通过编译源代码来保证应用程序的可移植性

- 进程内存结构

  - <img src="https://i.loli.net/2021/10/12/tuzIiNy4Qcm1ogs.jpg" alt="alt" style="zoom: 67%;" />
  - 顶部标记为argv、environ的空间爱你用于存储程序命令行实参和进程环境列表
  - 图中十六进制的地址会因为内核配置和程序链接选项差异而有所不同
  - 灰色区域表示这些范围在进程虚拟地址空间中不可用，没有为这些区域创建页表（page table）



### 虚拟内存管理

- 将每个程序使用的内存切割成小型的、固定大小的页
- RAM划分成一系列与虚拟内存页尺寸相同的页帧
- 驻留集：任一时刻，每个程序仅有部分页需要驻留在物理内存页帧中
- 交换区swap：程序未使用的页拷贝保存在交换区
  - 磁盘空间中的保留区域
  - 仅在需要时才会载入物理内存
- 若进程要访问的页当前未驻留在物理内存中，会发生 page fault ，内核立刻挂起进程的执行，同时将磁盘中的该页面载入内存
- sysconf(_SC_PAGESIZE) 获取系统虚拟内存的页面大小
- 

#### 页表

- 内核为每个进程维护一张页表（ page table ）
- 页表描述每页在进程虚拟地址空间中的位置，可以是进程所用的所有虚拟内存页面的集合
- 每个条目要么指出一个虚拟页面在RAM中所在位置，要么表明该虚拟页面驻留在磁盘上
- 进程虚拟地址空间中，并非所有地址范围都需要页表条目
  - 通常由于可能存在的大段虚拟地址空间并未投入使用，故而没有必要为其维护相应的页表条目
  - 若进程试图访问的地址没有页表条目与之对应，则会受到一个`SIGSEGV`信号
- 内核能够为进程分配和释放页和页表条目，进程有效虚拟地址范围在其生命周期中可以发生变化，可能的情况有：
  - 由于栈向下增长超出之前曾到达的位置
  - 堆在分配或释放内存时，通过brk() 、sbrk() 、malloc函数族 来提升program break 的位置
  - 调用 shmat() 连接 System V 共享内存区时
  - 调用 shmdt() 脱离共享内存区时
  - 调用 mmap() 创建内存映射时
  - 调用 munmap() 解除内存映射时
- 虚拟内存的实现需要硬件 PMMU 分页内存管理单元 的支持
  - PMMU 把要访问的每个虚拟内存地址转换成相应的物理内存地址，当特定的虚拟内存地址所对应的页没有驻留于RAM中时，将以 page fault 通知内核



#### 栈和栈帧

- 用户栈（user stack）即此处所讨论栈帧
- 内核栈
  - 是每个进程保留在内核内存的内存区域，在执行系统调用的过程中供内核内部函数调用使用
- 每个用户栈帧包含信息
  - 函数实参和局部变量
    - 这些变量都是在调用函数时自动创建的，因而在C语言中称为自动变量
    - 函数返回时自动销毁这些变量，栈帧会释放
    - 而静态（以及全局）变量与函数执行无关，且长期存在
  - 函数调用的链接信息
    - 每当一个函数调用另一个函数时，会在被调用函数的栈帧中保存这些寄存器的副本
- square() 函数执行期间，栈中的帧如图
  - <img src="https://i.loli.net/2021/10/12/PoyKCweZnz6lpas.png" alt="alt" style="zoom: 15%;" />

#### 命令行参数 argc argv

- argc 即为命令行参数的个数
- argv[] 是一个指向命令行参数的指针数组，每一个参数都是以NULL结尾的字符串
- argv 中的指针列表以 NULL 结尾，argv[0] 通常为程序的名称
- argc/argv 参数机制的仅对 main() 函数可用
  - 在保证可移植性的同时，使命令行参数能为其他函数所用，必须把argv以参数形式传递给这些参数，或设置指向argv的全局变量
  - 破坏可移植性的方法：
    - 通过Linux 专有的 /proc/PID/cmdline可以读取任一进程的命令行参数，每个参数都以NULL字节终止，程序可以通过/proc/self/cmdline 访问自身的命令行参数
    - GNU C 提供两个全局变量，可在程序的任一位置使用以获取调用改程序时的名称，即argv[0]
      - program_ivocation_name
        - 提供了用于调用该程序的完整路径名
      - program_invocation_short_name
        - 提供了不含目录的程序名称，即basename
      - 定义_GNU_SOURCE 宏后即可从<errno.h> 中获取对这两个全局变量的声明
- SUSv3 规定argv[] 的每个字符串
  - 确定上限值
    - ARG_MAX 常量（<limits.h>）
    - sysconf(_SC_ARG_MAX) 
  - ARG_MAX 常量下限为 _POSIX_ARG_MAX(4096) 个字节
  - 未规定ARG_MAX 的限制是否要将一些开销字节计算在内，如终止字符、字节对齐、argv、environ指针数组
- 使用`getopt()`库函数解析命令行选项，及以 “-” 开头的参数



#### 从程序中环境变量

- C 运行时启动代码定义了 `char **environ` 并以环境列表为其复制

  - environ 与 argv 参数类似，指向了以 NULL 结尾的指针列表，每个指针又指向一个以空字节终止的字符串
  - 需要使用`extern char **environ;`

- 也可以声明 main() 的第三个参数来访问环境列表

  - ```c
    int main(int argc, char *argv[], char *envp[])
    ```

  - envp[] 可以视为environ 变量来使用，不同在于作用于尽在main ()函数内
  
  - 不推荐使用，不在SUSv3 规范行列

##### getenv() 库函数

- ```c
  #include<stdlib.h>
  char *getenv(const char *name);
  ```

- 错误返回NULL

- 成功返回 string

- 不应直接修改 getenv() 函数返回的字符串

##### putenv() 库函数

- ```c
  #include<stdlib.h>
  int putenv(char *string);
  ```

- 成功返回0

- 错误返回非0

- putenv 函数将 string 指针 指向的字符串 作为environ变量的一部分，并非是 string 指向字符串的复制副本

- glibc 库 提供了非标准扩展

  - 若所给字符串不包含 ‘=’ 号，则将从环境列表中移除该环境变量



##### setenv() 库函数

- ```c
  #include<stdlib.h>
  int setenv(const char *name, const char *value, int overwrite);
  ```

- 成功返回 0

- 错误返回 -1

- 开辟一个内存缓冲区，将 name value 指向的字符串复制到缓冲区，以此来创建一个新的环境变量

- 不要在name的结尾处或value的开始处提供一个‘=’，setenv()  会在向环境添加新变量时添加等号字符

- 若 name 已存在

  - overwrite 为 0
    - 不改变环境
  - overwrite 为 非0
    - 总是改变环境

##### unsetenv() 库函数

- ```c
  #include<stdlib.h>
  int unsetenv(const char *name);
  ```

- 成功返回 0

- 错误返回 -1

- name参数不能包含 ‘=’



##### clearenv()

- ```c
  #define _BSD_SOURCE
  #include<stdlib.h>
  int clearenv(void)
  ```

- 成功返回 0

- 错误返回 -1

- 实现方法即为 `environ = NULL`

- 不断调用 `setenv()` 、`clearenv()` 会导致程序内存泄漏

- SUSv3 未规范 clearenv

- SUSv3 清空自身环境的唯一方法是首先获得所有环境变量，再逐一调用 unsetenv





### 跨函数跳转 setjmp() longjmp()

