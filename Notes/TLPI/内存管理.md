## 内存分配

### 调整 program break

#### brk()

- ```c
  #include<unistd.h>
  int brk(void *end_data_segment);
  ```

- 成功返回 0

- 错误返回 -1

- 系统调用brk() 将program break 设置为参数 end_data_segment 所指定的位置

- 以页为单位进行分配，end_data_segment 会四舍五入到下一个内存页的边界处

- 若将 program break 设置为低于其初始值 &end 时，会导致无法预知的行为

- program break 可以设定的精确上限取决于一系列因素，包括：

  - 进程对数据段大小的资源限制
  - 内存映射、共享内存段、共享库的位置

#### sbrk()

- ```c
  #include<unistd.h>
  int *sbrk(intptr_t increment);
  ```

- 成功返回前一个 program break 的地址，即新分配内存的起始位置

- 失败返回 -1

- sbrk使program break 在原有地址增加 increment 参数大小

- sbrk 基于 brk

- `sbrk(0)` 返回当前 program break 当前位置



### malloc() free()

- ````c
  #include<stdlib.h>
  void *malloc(size_t size);
  ````

- 成功返回指针

- 错误返回NULL

- malloc 基于8字节或16字节边界来分配内存

- SUSv3 规定

  - 调用malloc(0) 返回 NULL 或 一小块可释放内存
  - Linux 遵循一小块可释放内存

- 若无法分配内存

  - 则malloc返回NULL，并设置errno以返回错误信息

- ```c
  #include<stdlib.h>
  void free(void *ptr);
  ```

- 一般情况下，free() 并不降低 program break 的位置，而是将这块内存添加到空闲内存列表，供后续malloc循环使用

- 如果传给 free() 是一个空指针，则什么都不做

- 不能重复 free 同一个指针

- 进程终止时，其占用的所有内存都会自动释放

- 如果在堆顶部释放完整的一组连续内存块，则 program break 会从峰值上降下来，表明free 使用了 sbrk 来降低 program break

- 仅当堆顶空闲内存足够大时，glibc 的 free 函数会调用sbrk来降低 program break 的地址，是否足够大取决于malloc函数包的控制参数，一般为 128KB

### malloc 实现

- 流程
  - 扫描之前由free 所释放的空闲内存块列表
    - 找到尺寸大于等于要求的一块空闲内存
      - 若尺寸相当
        - 则直接返回
      - 若尺寸较大，
        - 则分割后，再返回
        - 剩余的空闲内存快继续保留在空闲列表中
  - 若找不到足够大的空闲内存块
    - 则调用 sbrk() 分配更多的内存
    - 将新分配的内存置于空闲内存列表中



### free 实现

- malloc 分配内存块时，会额外分配几个字节来存放这块内存大小的整数值，实际返回给调用者的内存地址恰好在这一长度记录字节之后
  - ![alt](https://i.loli.net/2021/10/12/TxV3wcFpgnJCAm9.jpg)
- 当内存块置于空闲内存列表（双向链表）时，free() 会使用内存快本身的空间来存放链表指针，将自身添加到列表中	
  - ![alt](https://i.loli.net/2021/10/12/J9qHG42BvWs3feC.jpg)
  - ![alt](https://i.loli.net/2021/10/12/jPWhDe693ycmUdL.jpg)



#### malloc free 使用注意：

- 分配一块内存，不要改变这块内存范围外的任何内容
- 不要多次释放同一块已分配内存，glibc库会报错 SIGSEGV 信号
- 若非经由 malloc 函数包中返回的指针，绝不能用 free() 
- 长时间运行的程序要确保释放所有已使用完毕的内存，避免内存泄漏



### malloc 调试工具和库

- 待续



### 在堆上分配内存的其他方法

#### calloc()

- ```c
  #include<stdlib.h>
  void *calloc(size_t numitems, size_t size);
  ```

- 成功返回指向这块内存起始处的指针

- 错误返回NULL

- numitems 指定分配对象的数量

- size 指定每个分配对象的大小

- 将已分配内存初始化为0

- ```c
   struct{
     /* Some definitions */  
   }myStruct;
    
   struct myStruct *p;
   p = calloc(1000, sizeof(struct myStruct));
   
   if(p == NULL)
       errExit("calloc");
   ```

#### realloc()

- ```c
  #include<stdlib.h>
  void *realloc(void *ptr,size_t size);
  ```

- ptr 是指向需要调整大下的内存快指针

- size指定所需调整大小的期望值

- 成功返回指针，指向大小调整后内存块的指针，与调用前的指针相比，位置可能不同

- 错误返回NULL，ptr指向的内存快原封不动

- 若 realloc() 增加了已分配内存的大小，则不会对额外分配的字节进行初始化

- 调用 realloc(ptr,0) 等效于 free(ptr) 之后调用malloc(0)

- realloc(NULL, size) 相当于调用 malloc(size)

- 通常情况下，当增大已分配内存时，realloc() 会试图合并在空闲列表中紧随其后且大小满足要求的内存快

- 若原内存快位于堆的顶部，则紧邻其后的空闲内存空间大小不足，realloc() 会分配一块新的内存，并将原有数据复制到新内存块中

  - 会占用大量CPU资源，一般尽量避免调用realloc()

- ```c
  nptr = realloc(ptr, newsize);
  if(nptr == NULL){
      /* Handle Error*/
  }else{
      ptr = nptr;
  }
  ```

  - 没有直接把 realloc() 返回值直接赋给 ptr，因为一旦realloc() 调用失败，则ptr会被置为 NULL，从而无法访问现有内存块

- 由于realloc 可能会移动内存块，任何指向该内存块内部的指针在调用 realloc() 之后都可能不可再用

#### memalign()

- ```c
  #include<malloc.h>
  
  void *memalign(size_t boundary, size_t size);
  ```

- 成功返回指针

- 错误返回NULL

- `memalign()` 分配size个字节的内存，起始地址是 boundary 的整数倍，而 boundary 必须是 2 的整数次幂

- SUSv3 并未纳入memalign()

- memalign() 并非在所有UNIX上都存在

#### posix_memalign()

- ```c
  #include<stdlib.h>
  
  int posix_memalign(void *memptr, size_t alignment, size_t size);
  ```

- 成功返回 0

- 错误返回正值错误号，类似于errno中返回的正整数

- `posix_memalign()` 与 `memalign()` 的不同

  - 已分配的内存地址通过参数 memptr 返回
  - 内存 与 alignment 参数的整数倍对齐
  - alignment 必须是 sizeof(void*)，多数硬件架构上是4或8个字节与2的整数次幂两者间的乘积

- 如果sizeof(void*)为4，则可以使用posix_memalign() 分配65536字节的内存，并与4096字节的边界对其

  - ```c
    int s;
    void *memptr;
    s = posix_memalign(&memptr, 1024*sizeof(void *),65536);
    if(s != 0){
        /* Handle Error */
    }
    ```

- 在一些UNIX实现中，无法调用free释放memalign分配的内存

  - glibc的 memalign() 不受此限制



#### alloca()

- ```c
  #include<alloca.h>
  
  void *alloca(size_t size);
  ```

- 通过增加栈帧的大小从堆栈上分配

- 当前调用函数的栈帧位于堆栈的顶部，帧的上方存在扩展空间，只需要修改堆栈指针值即可

- size 指定了在堆栈上分配的字节数

- 将指向已分配内存的指针作为返回值

- 不需要也不能用free释放由alloca分配的内存

- 不能调用realloc() 来调整由 alloca() 分配的内存大小

- SUSv3 未规范,但大多数UNIX实现都提供了此函数, 因而具有可移植性

- 若调用alloca 造成堆栈溢出,则程序行为无法预知,特别是在没有收到一个NULL返回值通知错误的情况下

- 不能在一个函数的参数列表中调用alloca , 如:

  - ```c
    func(x, alloca(size), z) //错误
    ```

  - 这会使alloca分配的堆栈空间出现在当前函数参数的空间内(函数参数都位于栈帧内的固定位置)

  - 应当:

  - ```c
    void *y;
    y = alloca(size);
    func(x,y,z); //正确
    ```

- alloca分配的内存随着栈帧的移除而自动释放,即调用alloca的函数返回时

- 在信号处理程序中调用longjmp() 或 siglongjmp()以执行非局部跳转时, alloca 的作用突出

- 在"起跳"函数 "落地"函数之间的函数中,如果使用了malloc 分配内存, 想要避免内存泄漏极其困难；而alloca可避免内存泄漏, 因为堆栈是由这些调用展开的, 所以分配的内存会被自动释放

