## 共享库版本

### 共享库版本兼容性

- 兼容更新
  - 原来所有的接口（ABI）都保持不变
- 不兼容更新
  - 共享库改变了原有的接口（ABI）
- 共享库ABI改变的情况
  - 导出函数的行为发生改变，调用此函数产生的结果与以前不同，不再满足旧版本规定的函数行为准则
  - 导出函数被删除
  - 导出数据的结构发生变化，如结构体变量的结构发生改变：结构成员删除、顺序改变或其他引起结构体内存布局改变的行为
  - 导出函数接口发生变化，如返回值、参数变化
- 导致ABI不兼容的一些情况
  - 编译器版本、系统库、操作系统、硬件平台等

- C++的ABI兼容非常困难，若使用C接口，会相对容易很多
- C++ ABI 兼容的建议
  - 不在接口类中使用虚函数
    - 若必须要使用，不要随意删除、添加或在子类中添加新的实现函数，这样会导致类的虚函数表结构发生变化
  - 不在改变类中任何成员变量的位置和类型
  - 不要删除非内嵌的public或protected 成员函数
  - 不要将非内嵌函数的成员函数改变成内嵌成员函数
  - 不要改变成员函数的访问权限
  - 不要在接口中使用模板

### 共享库版本命名

- 共享库命名规则
  - libname.so.x.y.z
  - “x” Major Version Number
    - 库的重大升级，不同主版本号的库之间不兼容
    - 依赖于旧的主版本号的程序需要改动相应部分，重新编译
    - 也可以保留旧版的共享库
  - “y” Minor Version Number
    - 表示库的增量升级，增加一些新的接口符号，并保持原来的符号不变
    - 主版本号相同时，高次版本号的库向后兼容低的次版本号的库
  - “z” Release Version Number
    - 表示库的一些错误修正、性能的改进等，并不添加任何新的接口，也不对接口进行更改
    - 相同主次版本号，不同发布版本号之间完全兼容
- Linux中存在不少不遵守上述规定的库
  - 如 Glibc libc-x.y.z.so, ld ld-x.y.z.so 等

### SO-NAME

- Linux 采用 SO-NAME 命名机制来记录共享库依赖关系
- 每个共享库都有一个对应的 SO-NAME，即共享库的文件名去掉次版本号、发布版本号，保留主版本号
- 次版本号大的库兼容此版本号小的库
- 系统为每个共享库在其目录创建一个跟 SO-NAME 相同的并且指向该共享库的 Symbol Link
  - Glibc libc.so.6 => libc-2.6.1.so （好像没有按照规则）
  - ld-linux.so => ld-2.6.1.so （不按照规则）
- 建立该软连接的目的在于，使得所有依赖某个共享库的模块，在编译、链接、运行时，都是用 SO-NAME，不适用详细版本号
- SO-NAME 表示一个库的接口，若接口不再向后兼容，SO-NAME 就发生变化
- Linux 中的工具 ldconfig
  - 当系统中安装或更新一个共享库时，就需要运行这个工具
  - ldconfig 会遍历所有默认共享库目录，如 /lib, /usr/lib，然后更新所有的软连接，使其指向最新版的共享库
  - 如果安装新的共享库，ldconfig 会为其创建相应的软连接
- 链接名
  - 若需要链接 libXXX.so.2.6.1的共享库时，只需要指定 `-l XXX`，可省略其余部分，编译器会根据当前环境，在系统中的相关路径（可由 -L 指定），查找最新版本的 XXX 库
  - 其中 XXX 为 共享库的链接名 Link Name
  - 不同类型的库可能有相同的链接名
  - 如C 运行库有静态版本 libc.a 、动态版本 libc.so.x.y.z，链接器会根据输出文件的情况（动态/静态）来选择适合版本的库
  - 也可以指定，ld 使用 `-static` 或 `-Bdynamic`



## 符号版本

z