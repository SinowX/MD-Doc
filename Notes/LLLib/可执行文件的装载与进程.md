## 从操作系统角度看可执行文件的装载

### 进程的建立

- 创建一个独立的虚拟地址空间
  - 并不是创建空间，而是创建映射函数所需要的相应的数据结构
  - i386 linux下，创建虚拟地址空间只是分配一个页目录  Page Directory，甚至不设置页映射关系，等到发生页错误时再进行设置
- 读取可执行文件头，并建立虚拟空间与可执行文件的映射关系
  - 建立虚拟空间与可执行文件的映射关系
  - 当发生页错误时，OS从物理内存中分配一个物理页，然后将该缺页从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系
  - 由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件 Image
  - 假设 ELF 只有一个 .text 段，虚拟地址为 0x08048000，大小为0x000e1，对齐为0x1000
    - 由于虚拟存储的页映射都是以页为单位的，IA32 下一般为 4096 字节，所以 32位 ELF 的对齐粒度为 0x1000
    - 由于 .text 段的大小不到一个页，为了对齐，.text 段占用一个段
  - 这种映射关系只是保存在OS内部的一个数据结构
    - 在程序执行发生段错误时，可以通过查找这样的一个数据结构来定位错误页在可执行文件中的位置
  - Linux 将进程虚拟空间中的一个段叫做虚拟内存区域 VMA，Virtual Memory Area
- 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行
  - OS通过设置CPU指令寄存器将控制权转交给进程，由此进程开始执行



### 页错误

- 假设上面的例子中，程序入口地址为 0x08048000，即刚好时 .text 段的起始地址
- 当CPU开始要执行这个地址的指令时，发现页面 0x08048000~0x08049000 是个空页面，于是认为这是一个页错误 Page Fault
- CPU 将控制权交给OS，OS通过查询第二步的数据结构，找到空页面所在的 VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系
- 然后把控制权交还给进程，进程从发生页错误的位置重新开始执行
- <img src="https://i.loli.net/2021/10/12/mnHufIZDErVlTPL.png" alt="image-20210829141929731" style="zoom:50%;" />





## 进程虚拟内存空间分布

### ELF文件链接视图与执行视图

- 当段的数量增多时，由于对齐机制，会产生较多空间浪费问题
- ELF 段根据权限基本分为三种
  - 以代码段为代表的权限为刻度可执行的段
  - 以数据段和 BSS 段为代表的权限为可读可写的段
  - 以只读数据段为代表的权限为只读的段
- ELF可执行文件引入了 Segment 概念
  - 如果 .text .init 段合并在一起作为一个 Segment，则装载的时候就可以将其作为一个整体一起映射，映射之后，在进程虚拟内存空间中只有一个相对应的 VMA
  - 这样做可以明显减少页面内部碎片，从而节省了内存空间
- 在目标文件链接为可执行文件的时候，链接器会尽量把相同的权限属性的段分配在同一个空间，称为 Section
- 在ELF中把着些属性相似，又连在一起的段，称为 Segment

```c
//SectionMapping.c
#include <stdlib.h>
#include <unistd.h>

int main()
{
	while(1) sleep(1000);
	return 0;
}
```

```bash
[sinow@Arch test]$ readelf -S SectionMapping.elf  # 查看 Section
There are 32 section headers, starting at offset 0xc2200:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .note.gnu.pr[...] NOTE             0000000000400270  00000270
       0000000000000040  0000000000000000   A       0     0     8
  [ 2] .note.gnu.bu[...] NOTE             00000000004002b0  000002b0
       0000000000000024  0000000000000000   A       0     0     4
  [ 3] .note.ABI-tag     NOTE             00000000004002d4  000002d4
       0000000000000020  0000000000000000   A       0     0     4
  [ 4] .rela.plt         RELA             00000000004002f8  000002f8
       0000000000000240  0000000000000018  AI       0    20     8
  [ 5] .init             PROGBITS         0000000000401000  00001000
       000000000000001b  0000000000000000  AX       0     0     4
  [ 6] .plt              PROGBITS         0000000000401020  00001020
       00000000000000c0  0000000000000000  AX       0     0     8
  [ 7] .text             PROGBITS         00000000004010e0  000010e0
       000000000007ff00  0000000000000000  AX       0     0     16
  [ 8] __libc_freeres_fn PROGBITS         0000000000480fe0  00080fe0
       0000000000000ac0  0000000000000000  AX       0     0     16
  [ 9] .fini             PROGBITS         0000000000481aa0  00081aa0
       000000000000000d  0000000000000000  AX       0     0     4
  [10] .rodata           PROGBITS         0000000000482000  00082000
       000000000001c124  0000000000000000   A       0     0     32
  [11] .stapsdt.base     PROGBITS         000000000049e124  0009e124
       0000000000000001  0000000000000000   A       0     0     1
  [12] .eh_frame         PROGBITS         000000000049e128  0009e128
       000000000000a984  0000000000000000   A       0     0     8
  [13] .gcc_except_table PROGBITS         00000000004a8aac  000a8aac
       00000000000000bc  0000000000000000   A       0     0     1
  [14] .tdata            PROGBITS         00000000004aa908  000a9908
       0000000000000020  0000000000000000 WAT       0     0     8
  [15] .tbss             NOBITS           00000000004aa928  000a9928
       0000000000000040  0000000000000000 WAT       0     0     8
  [16] .init_array       INIT_ARRAY       00000000004aa928  000a9928
       0000000000000008  0000000000000008  WA       0     0     8
  [17] .fini_array       FINI_ARRAY       00000000004aa930  000a9930
       0000000000000010  0000000000000008  WA       0     0     8
  [18] .data.rel.ro      PROGBITS         00000000004aa940  000a9940
       00000000000035b4  0000000000000000  WA       0     0     32
  [19] .got              PROGBITS         00000000004adef8  000acef8
       00000000000000f0  0000000000000000  WA       0     0     8
  [20] .got.plt          PROGBITS         00000000004ae000  000ad000
       00000000000000d8  0000000000000008  WA       0     0     8
  [21] .data             PROGBITS         00000000004ae0e0  000ad0e0
       0000000000001a50  0000000000000000  WA       0     0     32
  [22] __libc_subfreeres PROGBITS         00000000004afb30  000aeb30
       0000000000000048  0000000000000000  WA       0     0     8
  [23] __libc_IO_vtables PROGBITS         00000000004afb80  000aeb80
       0000000000000768  0000000000000000  WA       0     0     32
  [24] __libc_atexit     PROGBITS         00000000004b02e8  000af2e8
       0000000000000008  0000000000000000  WA       0     0     8
  [25] .bss              NOBITS           00000000004b0300  000af2f0
       00000000000018a0  0000000000000000  WA       0     0     32
  [26] __libc_freer[...] NOBITS           00000000004b1ba0  000af2f0
       0000000000000020  0000000000000000  WA       0     0     8
  [27] .comment          PROGBITS         0000000000000000  000af2f0
       0000000000000012  0000000000000001  MS       0     0     1
  [28] .note.stapsdt     NOTE             0000000000000000  000af304
       00000000000011c4  0000000000000000           0     0     4
  [29] .symtab           SYMTAB           0000000000000000  000b04c8
       000000000000b2b0  0000000000000018          30   730     8
  [30] .strtab           STRTAB           0000000000000000  000bb778
       0000000000006930  0000000000000000           0     0     1
  [31] .shstrtab         STRTAB           0000000000000000  000c20a8
       0000000000000157  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
[sinow@Arch test]$ readelf -l SectionMapping.elf # 查看Segment

Elf file type is EXEC (Executable file)
Entry point 0x401670
There are 10 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000538 0x0000000000000538  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x0000000000080aad 0x0000000000080aad  R E    0x1000
  LOAD           0x0000000000082000 0x0000000000482000 0x0000000000482000
                 0x0000000000026b68 0x0000000000026b68  R      0x1000
  LOAD           0x00000000000a9908 0x00000000004aa908 0x00000000004aa908
                 0x00000000000059e8 0x00000000000072b8  RW     0x1000
  NOTE           0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000040 0x0000000000000040  R      0x8
  NOTE           0x00000000000002b0 0x00000000004002b0 0x00000000004002b0
                 0x0000000000000044 0x0000000000000044  R      0x4
  TLS            0x00000000000a9908 0x00000000004aa908 0x00000000004aa908
                 0x0000000000000020 0x0000000000000060  R      0x8
  GNU_PROPERTY   0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000040 0x0000000000000040  R      0x8
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x00000000000a9908 0x00000000004aa908 0x00000000004aa908
                 0x00000000000036f8 0x00000000000036f8  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt 
   01     .init .plt .text __libc_freeres_fn .fini 
   02     .rodata .stapsdt.base .eh_frame .gcc_except_table 
   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs 
   04     .note.gnu.property 
   05     .note.gnu.build-id .note.ABI-tag 
   06     .tdata .tbss 
   07     .note.gnu.property 
   08     
   09     .tdata .init_array .fini_array .data.rel.ro .got 

```



- “Segment”和“Section”是从不同的角度来划分同一个ELF文件。
- 这个在ELF中被称为不同的视图（View），从“Section”的角度来看ELF文件就是链接视图（Linking View），从“Segment”的角度来看就是执行视图（Execution View）。



- ELF 可执行文件中又一个专门的数据结构叫做程序头表 Program Header Table，用于保存Segment 信息

- ELF目标文件不许要装载，所以没有程序头表

- ELF可执行文件和共享库文件都有程序头表

- 程序头表结构体

  - ```cc
    typedef struct {
        Elf32_Word p_type;
        Elf32_Off p_offset;
        Elf32_Addr p_vaddr;
        Elf32_Addr p_paddr;
        Elf32_Word p_filesz;
        Elf32_Word p_memsz;
        Elf32_Word p_flags;
        Elf32_Word p_align;
    } Elf32_Phdr;
    ```

  - | 成员     | 含义                                                         |
    | -------- | ------------------------------------------------------------ |
    | p_type   | “Segment” 的类型，包括 LOAD、DYNAMIC、INTERP 等              |
    | p_offset | Segment 在文件中的偏移                                       |
    | p_vaddr  | Segment 第一个字节在进程虚拟地址空间的起始位置，整个程序头表中，所有 LOAD 类型的元素按照 p_vaddr 从小到大排列 |
    | p_paddr  | Segment 的物理装载地址，LMA（Load Memory Address），一般情况下，p_paddr 和 p_vaddr 是一样的 |
    | p_filesz | Segment 在 ELF 文件中所占空间的长度，其值可能为0，因为有可能这个 Segment 在 文件中不存在内容 |
    | p_memse  | Segment 在进程虚拟地址空间中所占的长度，可能为0              |
    | p_flags  | Segment 的权限属性 RWX                                       |
    | p_align  | Segment 的对齐属性，实际对齐字节等于2的 p_align 次           |

  - p_memsz 大于 等于 p_filesz

  - p_memsz 大于 p_filesz 时表示

    - 该Segment在内存中所分配的空间大小超过文件中实际的大小，多余部分全部填充为0
    - 好处在于构造 ELF 可执行文件时不需要再额外设立 BSS 的 Segment，可以把 数据 Segment 的 p_memsz 扩大，其额外部分就是 BSS
    - 数据段与 BSS 的唯一区别
      - 数据段从文件中初始化内容，而BSS的内容全都初始化为 0

### 堆和栈

- VMA 除了被用来映射可执行文件的各个Segment外，还可以对进程的地址空间进行管理

- 进程执行的时候还需要用到 Stack 、Heap 等空间，

- 很多情况下，一个进程中的 Stack 和 Heap 分别都有一个对应的 VMA

  - ```bash
    [sinow@Arch test]$ ./SectionMapping.elf &
    [1] 6819
    [sinow@Arch test]$ cat /proc/6819/maps 
    00400000-00401000 r--p 00000000 103:08 5589514                           /home/sinow/workspace/cpp/test/SectionMapping.elf
    00401000-00482000 r-xp 00001000 103:08 5589514                           /home/sinow/workspace/cpp/test/SectionMapping.elf
    00482000-004a9000 r--p 00082000 103:08 5589514                           /home/sinow/workspace/cpp/test/SectionMapping.elf
    004aa000-004ae000 r--p 000a9000 103:08 5589514                           /home/sinow/workspace/cpp/test/SectionMapping.elf
    004ae000-004b1000 rw-p 000ad000 103:08 5589514                           /home/sinow/workspace/cpp/test/SectionMapping.elf
    004b1000-004b2000 rw-p 00000000 00:00 0 
    023aa000-023cc000 rw-p 00000000 00:00 0                                  [heap]
    7ffe24361000-7ffe24382000 rw-p 00000000 00:00 0                          [stack]
    7ffe243c8000-7ffe243cc000 r--p 00000000 00:00 0                          [vvar]
    7ffe243cc000-7ffe243ce000 r-xp 00000000 00:00 0                          [vdso]
    ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
    
    ```

  - 第一列表示 VMA的地址范围

  - 第二列表示权限， p表示私有，s 表示共享

  - 第三列表示偏移，表示 VMA 对应的 Segment 在 映像文件中的 偏移

  - 第四列表示映像文件所在设备的主设备号和次设备号

  - 第五列表示映像文件的结点号

  - 最后一列表示映像文件的路径

  - 可以看到进程有11个VMA，

    - 前5个是映射到可执行文件中的两个Segment
    - 另外6个段所在设备主设备号和此设备号和文件结点号都是0，表示其没有映射到文件中，这中VMA 称为匿名虚拟内存区域 Anonymous Virtual Memory Area
    - 可以看到有两个区域分别是 Heap 和 Stack，每个线程都有属于自己的堆栈，对于单线程的程序来说，这个VMA堆栈全都归它所有
    - 有一个VMA叫做 vdso，其地址位于内和空间，其实它是一个内核的模块，进程可以通过访问这个VMA来跟内核进行一些通信

- 操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；

- 基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA；

- 一个进程基本上可以分为如下几种VMA区域

  - 代码VMA
    - 只读、可执行，有映像文件
  - 数据VMA
    - 读写、可执行，有映像文件
  - 堆VMA
    - 读写、可执行，无映像文件，匿名，可向上扩展
  - 栈VMA
    - 读写、不可执行，无映像文件，匿名，可向下扩展

- <img src="https://i.loli.net/2021/10/12/jHB6rvJVy5IS8uT.png" alt="image-20210829160801924" style="zoom:50%;" />
- /proc 目录里面看到的 VMA2 的结束地址和预测的不一样，按照计算应该是 0x080bc000，实际显示的是 0x080bb000
- 这是因为Linux在装载ELF文件时，实现了一种 Hack做法，
- 因为Linux的进程虚拟空间管理的 VMA的概念并非与Segment完全对应
  - Linux规定一个VMA可以映射到某个文件的一个区域，或者是没有映射到任何文件
- 而此处的第二个 Segment 要求是，前面部分映射到文件中，后面部分不映射到文件，直接为0
  - 即前面从 .tdata 到 .data 段部分要建立从虚拟空间到文件的映射，
  - 而.bss 和 __libcfreeres_ptrs 部分不映射到文件
  - 这样两个概念就不完全相同了
- 这样两个概念就不完全相同了
- 所以Linux实际上采用了一种取巧的办法
  - 它在映射完第二个“Segment”之后，把最后一个页面的剩余部分清0，然后
    调用内核中的do_brk()，把“.bss”和“__libcfreeres_ptrs”的剩余部分放到堆段中。



### 堆的最大申请数量

- malloc 申请数量影响因素
  - 操作系统版本、程序本身大小、用到的动态/共享库数量、大小、程序栈数量、大
    小等
  - 甚至有可能每次运行的结果都会不同，因为有些操作系统使用了一种叫做随机地址空间分布的技术s（主要是出于安全考虑，防止程序受恶意攻击），使得进程的堆空间变小。

```cc
// 测试 malloc 最大内存申请数量
#include <stdio.h>
#include <stdlib.h>
unsigned maximum = 0;
int main(int argc, char *argv[]) 
{
    unsigned blocksize[] = { 1024 * 1024, 1024, 1 };
    int i, count;
    for(i = 0; i < 3; i++) {
        for(count = 1;; count++) {
            void *block = malloc( maximum + blocksize[i] * count); 
            if (block) {
                maximum = maximum + blocksize[i] * count;
                free(block);
            } else {
                break;
            }
        }
    }
    printf("maximum malloc size = %u bytes\n", maximum);
}
```





### 段地址对齐

- 对于 Intel 80x86 系列处理器来说，默认的页大小为4096字节

- 将一段物理内存和进程虚拟内存之间建立映射关系

  - 这段内存空间的长度必须是4096的整数倍
  - 这段空间在物理内存和进程虚拟地址空间中的起始地址必须是4096的整数倍

- 假设有一个ELF可执行文件，有三个 Segment 需要装载

  - | Segment | 长度（字节） | 偏移（字节） | 权限 |
    | ------- | ------------ | ------------ | ---- |
    | SEG0    | 127          | 34           | rx   |
    | SEG1    | 9899         | 164          | rw   |
    | SEG2    | 1988         |              | r    |

  -  每个段都不是页长度的整数倍

  - 令各个段接壤部分共享一个物理页面，将该物理页面分别映射两次

  - <img src="https://i.loli.net/2021/10/12/ez6o8uF7JrUNpIm.png" alt="image-20210830103828026" style="zoom:50%;" />

  - 如SEG0 和 SEG1 的接壤部分的那个物理页，系统将其映射两份到虚拟地址空间，一份为 SEG0，一份为 SEG1，其他的页面都按照正常的页粒度进行映射

  - ELF文件头也看做是一个段，将其映射到进程的地址空间，这样做的好处是进程中的某一段区域就是整个ELF文件的映像，便于需要访问ELF文件头的操作（如动态链接）

  - ELF文件从最开始到某个点结束，被逻辑上分成了以4096字节为单位的若干个块，每个块都被装载到物理内存中，对于那些位于两个段中间的块，会被映射两次

  - | Segment | 起始虚拟地址 | 长度（字节） | 偏移（字节） | 权限 |
    | ------- | ------------ | ------------ | ------------ | ---- |
    | SEG0    | 0x08048022   | 127          | 34           | rx   |
    | SEG1    | 0x080490A4   | 9899         | 164          | rw   |
    | SEG2    | 0x0804C74F   | 1988         |              | r    |

  - <img src="https://i.loli.net/2021/10/12/U3ZgCox1l5hRqsV.png" alt="image-20210830105023219" style="zoom:50%;" />

  - 这种情况下，本来要用到5个物理页面，即20480字节的内存，现在只需要3个页面，即12288字节

  - 对于一个物理页面来说，它可能同时包含了两个或多个段，比如文件头、代码段、数据段、BSS段的长度加起来都没有超过4096字节

  - 由于段地址对齐，各个段的虚拟地址往往不是系统页面长度的整数倍

  - VMA0 的起始地址是0x08048000，长度为0x709E5，所以VMA0结束地址为0x080B89E5

  - VMA1因为和VMA0的最后一个虚拟页面共享一个物理页面，并且映射两遍，所以其虚拟地址应该是0x080B99E5，又因为段必须是4字节(32位)的倍数，所以向上取整0x080B99E8

  - 规律

    - 在ELF文件中，对于任何一个可装载的“Segment”，它的p_vaddr除以对齐属性的余数等于p_offset除以对齐属性的余数。



### 进程栈的初始化

- 系统环境变量和进程的运行参数保存在进程的虚拟空间的栈中，即VMA中的 Stack VMA
- 假设
  - 有两个环境变量 `HOME=/home/user`、`PATH=/usr/bin`
  - 运行命令 `prog 123`
  - 堆栈底部地址为 0xBF802000
- 则进程初始化后的堆栈为
  - <img src="https://i.loli.net/2021/10/12/DulJq47iP9CfUQ5.png" alt="image-20210830110230459" style="zoom:50%;" />
  - esp(栈顶寄存器)指向初始化以后堆栈的顶部
  - 对前面4个字节表示命令行参数的数量
  - 接着是指向这两个参数字符串的指针，后面跟着一个0
  - 接着是指向环境变量字符串的指针，后面跟着一个0
  - 进程在程序启动后，程序的库部分会把堆栈里的初始化信息中的参数信息传递给main()函数





## Linux 内核装载 ELF 过程简介

- 在bash下输入一个命令执行某个 ELF 程序

- 在用户层面
  - bash 进程会调用fork()系统调用，创建一个新的进程，然后新的进程调用execve()系统调用执行 ELF 文件，
  - 原先的bash进程继续返回等待刚才启动的新进程结束
- 进入 execve() 系统调用后，Linux内核开始进行真正的装载工作
  - 内核中，execve() 的相应入口时 sys_execve()，定义在 arch/i386/kernel/Process.c
  - sys_execve() 进行一些参数的检查复制之后，调用do_execve()
  - do_execve() 首先查找被执行的文件，若找到文件，则读取文件的前128个字节，用于判断文件的格式，如ELF可执行文件格式的前4个字节为 0x7F、'e'、'l'、'f'，解释型语言的脚本，前两个字节 '#'、'!' 构成了魔数
  - 当 do_execve() 读取了这128个字节的文件头部后，调用 search_binary_handle() 去搜索和匹配合适的可执行文件装载处理过程
  - Linux中所有被支持的可执行文件格式都会有相应的装载处理过程
  - search_binary_handle() 会通过判断文件头部的魔数确定文件的格式，并调用相应的装载处理过程
    - 如 ELF load_elf_binary()、a.out 可执行文件 load_aout_binary()、可执行脚本程序 load_script()
  - load_elf_binary()定义在 fs/Binfmt_elf.c
    - 检查 ELF 的有效性，如魔数、程序头表中Segment的数量
    - 寻找动态链接的 ".interp" 段，设置动态链接器路径
    - 根据ELF可执行文件的程序头表的描述，对 ELF 文件进行映射，如代码、数据、只读数据
    - 初始化 ELF 进程环境，如进程启动时EDX寄存器的地址应该是 DT_FINI 的地址
    - 将系统调用的返回地址修改成ELF可执行文件的入口点
      - 这个入口点取决于程序的链接方式
      - 对于静态链接ELF 可执行文件，这个程序入口就是ELF文件的文件头中e_entry所指的地址
      - 对于动态链接的 ELF 可执行文件，程序入口点就是动态链接器
  - load_elf_binary() 执行完毕，返回 do_execve()，再返回到 sys_execve()时，上面第五步中已经把系统调用的返回地址改成了被装载的 ELF 程序的入口地址了
  - 所以 sys_execve() 从内核态返回到用户态时，EIP寄存器直接跳转到了 ELF 程序的入口地址
  - 于是新的程序开始执行，ELF可执行文件装载完成
