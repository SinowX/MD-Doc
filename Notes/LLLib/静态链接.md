## 静态链接

- 示例代码

- ```c
  /* a.c */
  extern int shared;
  
  int main(){ // 全局符号
  	int a=100;
  	swap( &a, &shared );
  }
  
  /* b.c */
  int shared = 1; // 全局变量
  void swap(int *a, int* b) // 全局变量
  {
  	*a ^= *b ^=*a ^=*b;
  }
  ```

- ```bash
  gcc -c a.c -fno-stack-protector
  gcc -c b.c -fno-stack-protector
  
  #得到文件 a.o b.o
  ```

- 将 a.o b.o 两个目标文件链接起来形成呢该一个可执行文件 ab



### 空间与地址分配

#### 相似段合并

![](https://i.loli.net/2021/10/12/8TjucP2rAL6GM9o.jpg)

- 链接器为目标文件分配地址和空间

  1. 输出的可执行文件中的空间
  2. 装载后的虚拟地址中的虚拟地址空间

  - .text .data 在文件和虚拟地址都要分配空间
  - .bss 只局限于虚拟地址空间，在文件中没有内容

- 两步链接 Two-pass Linking

  1. 空间与地址分配
     - 扫描所有输入目标文件，获取各段长度、属性、位置
     - 将输入目标文件中的符号表中所有符号定义与符号引用收集起来，统一放到一个全局符号表
     - 链接器获得所有输入目标文件的段长度，合并，计算输出文件中各段合并后的长度与位置，建立映射关系
  2. 符号解析与重定位
     - 使用上一步收集到的所有信息，读取输入文件中段的数据、重定位信息
     - 进行符号解析、重定位（核心）、调整代码中的地址



```bash
[sinow@Arch test]$ ld a.o b.o -e main -o ab


[sinow@Arch test]$ objdump -h a.o 

a.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000031  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000071  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000071  2**0
                  ALLOC
  3 .comment      00000013  0000000000000000  0000000000000000  00000071  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000084  2**0
                  CONTENTS, READONLY
  5 .note.gnu.property 00000030  0000000000000000  0000000000000000  00000088  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000b8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

[sinow@Arch test]$ objdump -h b.o 

b.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000004b  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  0000000000000000  0000000000000000  0000008c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000090  2**0
                  ALLOC
  3 .comment      00000013  0000000000000000  0000000000000000  00000090  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000a3  2**0
                  CONTENTS, READONLY
  5 .note.gnu.property 00000030  0000000000000000  0000000000000000  000000a8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000d8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

[sinow@Arch test]$ objdump -h ab 

ab:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .note.gnu.property 00000030  00000000004001c8  00000000004001c8  000001c8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000007c  0000000000401000  0000000000401000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .eh_frame     00000058  0000000000402000  0000000000402000  00002000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00000004  0000000000404000  0000000000404000  00003000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000012  0000000000000000  0000000000000000  00003004  2**0
                  CONTENTS, READONLY

```

- VMA 虚拟地址 Virtual Memory Address
- LMA 加载地址 Load Memory Address
- 通常两者相同，在有些嵌入式系统中可能不同
- File off 文件偏移
- 连接前，目标文件中所有段的 VMA 都是 0，因为虚拟空间还没有分配

- 连接前后目标文件各段的分配、程序虚拟地址如图（书中原图）
  - <img src="https://i.loli.net/2021/10/12/43bkn5QcBljFeYs.png" alt="image-20210820125311558" style="zoom: 67%;" />
- 忽略了 .comment，只关心代码段和数据段，本例中没有 .bss 段，将其简化了
- a.o, b.o 中的 代码段叠加合并成 ab 中的 代码段，加起来长度符合预期
- 在Linux下，ELF可执行文件默认从地址0x08048000开始分配(可能是32位吧)



#### 符号地址的确定

- 在第一步 扫描和空间分配 阶段，连接器按照前面的空间分配方法进行分配，这时候，各个段在链接后的虚拟地址就已经确定了
- 然后连接器开始计算各个符号的虚拟地址
  - 由于各个符号在段内的相对地址固定，其实“main”、“shared”、“swap”的地址也是确定的，只不过链接器要给每个符号加上一个偏移量
  - 比如我们假设“a.o”中的“main”函数相对于“a.o”的“.text”段的偏移是X，但是经过链接合并以后，“a.o”的“.text”段位于虚拟地址0x08048094，那么“main”的地址应该是0x08048094 + X。



### 符号解析和重定位

#### 重定位

```bash
[sinow@Arch test]$ objdump -d a.o # 反汇编代码段

a.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	c7 45 fc 64 00 00 00 	movl   $0x64,-0x4(%rbp)
   f:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  13:	48 8d 15 00 00 00 00 	lea    0x0(%rip),%rdx        # 1a <main+0x1a>
  1a:	48 89 d6             	mov    %rdx,%rsi
  1d:	48 89 c7             	mov    %rax,%rdi
  20:	b8 00 00 00 00       	mov    $0x0,%eax
  25:	e8 00 00 00 00       	call   2a <main+0x2a> ## 重点关注函数调用
  2a:	b8 00 00 00 00       	mov    $0x0,%eax
  2f:	c9                   	leave  
  30:	c3                   	ret    
[sinow@Arch test]$ objdump -d ab 

ab:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <main>:
  401000:	55                   	push   %rbp
  401001:	48 89 e5             	mov    %rsp,%rbp
  401004:	48 83 ec 10          	sub    $0x10,%rsp
  401008:	c7 45 fc 64 00 00 00 	movl   $0x64,-0x4(%rbp)
  40100f:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  401013:	48 8d 15 e6 2f 00 00 	lea    0x2fe6(%rip),%rdx        # 404000 <shared>
  40101a:	48 89 d6             	mov    %rdx,%rsi
  40101d:	48 89 c7             	mov    %rax,%rdi
  401020:	b8 00 00 00 00       	mov    $0x0,%eax
  401025:	e8 07 00 00 00       	call   401031 <swap> ## 重点关注函数调用,swap地址已确定
  40102a:	b8 00 00 00 00       	mov    $0x0,%eax
  40102f:	c9                   	leave  
  401030:	c3                   	ret    

0000000000401031 <swap>:
  401031:	55                   	push   %rbp
  401032:	48 89 e5             	mov    %rsp,%rbp
  401035:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  401039:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  40103d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401041:	8b 10                	mov    (%rax),%edx
  401043:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401047:	8b 00                	mov    (%rax),%eax
  401049:	31 c2                	xor    %eax,%edx
  40104b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40104f:	89 10                	mov    %edx,(%rax)
  401051:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401055:	8b 10                	mov    (%rax),%edx
  401057:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40105b:	8b 00                	mov    (%rax),%eax
  40105d:	31 c2                	xor    %eax,%edx
  40105f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401063:	89 10                	mov    %edx,(%rax)
  401065:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401069:	8b 10                	mov    (%rax),%edx
  40106b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40106f:	8b 00                	mov    (%rax),%eax
  401071:	31 c2                	xor    %eax,%edx
  401073:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401077:	89 10                	mov    %edx,(%rax)
  401079:	90                   	nop
  40107a:	5d                   	pop    %rbp
  40107b:	c3                   	ret    

```



#### 重定位表(段) Relocation Table

- 重定位表在ELF中往往是一个或者多个段

- 比如代码段“.text”如有要被重定位的地方，那么会有一个相对应叫“.rel.text”的段
  保存了代码段的重定位表；如果代码段“.data”有要被重定位的地方，就会有一个相对应叫“.rel.data”的段保存了数据段的重定位表。

- ```bash
  [sinow@Arch test]$ objdump -r a.o 
  
  a.o:     file format elf64-x86-64
  
  RELOCATION RECORDS FOR [.text]:
  OFFSET           TYPE              VALUE 
  0000000000000016 R_X86_64_PC32     shared-0x0000000000000004
  0000000000000026 R_X86_64_PLT32    swap-0x0000000000000004
  
  
  RELOCATION RECORDS FOR [.eh_frame]:
  OFFSET           TYPE              VALUE 
  0000000000000020 R_X86_64_PC32     .text
  
  ```

- 每个要被重定位的地方叫一个重定位入口 Relocation Entry

- a.o 里边有两个重定位入口，Offset 表示该入口在要被重定位的段中的位置

- RELOCATION RECORDS FOR [.text] 表示这个是代码段的重定位表

- 这里的 0x16、0x26 分别就是代码段里 shared、swap 的地址(偏移量)

- 对于 32-i386 来说，重定位表是一个Elf32_Rel 结构的数组，每个数组元素对应一个重定位入口

- ```c
  typedef struct{
      ELf32_Addr r_offset;
      Elf32_Word r_info;
  } Elf32_Rel;
  ```

- 

  | 变量     | 描述                                                         |
  | -------- | ------------------------------------------------------------ |
  | r_offset | 重定位入口的偏移。<br>对于可重定位文件来说，这个值是该重定位入口所要修正的第一个字节相对于段起始的偏移；<br>对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的未知的第一个字节的虚拟地址。<br>我们这里只关心可重定位文件的情况，可执行文件或共享对象文件的情况见动态链接 |
  | r_info   | 重定位入口的类型和符号。<br>这个成员的低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表中的下标<br>因为各种处理器的指令格式不一样，所以重定位所修正的指令地址格式也不一样，每种处理器都有自己一套重定位入口的类型。<br>对于可执行文件和共享目标文件来说，他们的重定向入口时动态链接类型的 |



#### 符号解析

- 其实重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器须要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。

- ```bash
  [sinow@Arch test]$ readelf -s a.o # 查看符号表
  
  Symbol table '.symtab' contains 7 entries:
     Num:    Value          Size Type    Bind   Vis      Ndx Name
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
       1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c
       2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
       3: 0000000000000000    49 FUNC    GLOBAL DEFAULT    1 main
       4: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND shared #UND 未定义
       5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
       6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND swap
  [sinow@Arch test]$ readelf -s b.o
  
  Symbol table '.symtab' contains 5 entries:
     Num:    Value          Size Type    Bind   Vis      Ndx Name
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
       1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS b.c
       2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
       3: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    2 shared
       4: 0000000000000000    75 FUNC    GLOBAL DEFAULT    1 swap
  [sinow@Arch test]$ readelf -s ab
  
  Symbol table '.symtab' contains 9 entries:
     Num:    Value          Size Type    Bind   Vis      Ndx Name
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
       1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c
       2: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS b.c
       3: 0000000000401031    75 FUNC    GLOBAL DEFAULT    2 swap
       4: 0000000000404000     4 OBJECT  GLOBAL DEFAULT    4 shared
       5: 0000000000404004     0 NOTYPE  GLOBAL DEFAULT    4 __bss_start
       6: 0000000000401000    49 FUNC    GLOBAL DEFAULT    2 main
       7: 0000000000404004     0 NOTYPE  GLOBAL DEFAULT    4 _edata
       8: 0000000000404008     0 NOTYPE  GLOBAL DEFAULT    4 _end
  
  ```

- 未定义的符号都是因为该目标文件中有关于它们的重定位项。所以在链接器扫描完所有的输入目标文件之后，所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错



####  指令修正方式

- 直至2006年为止，Intel x86系列CPU的jmp指令有11种寻址模式；call指令有10种；mov
  指令则有多达34种寻址模式！这些寻址方式有如下几方面的区别：
  - 近址寻址或远址寻址。
  - 绝对寻址或相对寻址。
  - 寻址长度为8位、16位、32位或64位。
- 但是对于32位x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种
  - 绝对近址32位寻址。
  - 相对近址32位寻址。

- 这两种重定位方式指令修正方式每个被修正的位置的长度都为32位，即4个字节。而且都是近址寻址，不用考虑Intel的段间远址寻址。唯一的区别就是绝对寻址和相对寻址。

- 前面我们提到过，重定位入口的r_info成员低8位表示重定位入口类型

- | 宏定义     | 值   | 重定位修正方法     |
  | ---------- | ---- | ------------------ |
  | R_386_32   | 1    | 绝对寻址修正 S+A   |
  | R_386_PC32 | 2    | 相对寻址修正 S+A-P |
  - A = 保存在被修正位置的值
  - P = 被修正的位置，相对于段开始的偏移量或者虚拟地址，该值可通过 r_offset 计算得到
  - S = 符号的实际地址，即由 r_info 的高 24 位指定的符号的实际地址

- 从这两个例子可以看出来，绝对寻址修正和相对寻址修正的区别就是

  - 绝对寻址修正后的地址为该符号的实际地址；
  - 相对寻址修正后的地址为符号距离被修正位置的地址差。

- （正文）

- 对照前面a.o的重定位信息，我们可以看到第一个重定位入口是对swap符号的引用，类型为R_386_PC32，查阅Intel指令手册，它的确是一条相对位移调用指令；而shared是R_386_32类型的，它修正的是一条传输指令的源，该传输指令的源是一个立即数，即shared的绝对地址。所以这两个重定位入口很具有代表性，分别代表了两种不同的重定位地址修正方式。

- 现在让我们假设在将a.o和b.o链接成最终可执行文件后，main函数的虚拟地址为0x1000，swap函数的虚拟地址为0x2000；shared变量的虚拟地址为0x3000。那么我们的链接器将如何修正a.o里面这两个重定位入口呢？

- 绝对寻址修正 让我们先看a.o的第一个重定位入口，即偏移为0x18的这条mov指令的修正，它的修正方式是
  R_386_32，即绝对地址修正。对于这个重定位入口，它修正后的结果应该是S + A。

  - S是符号shared的实际地址，即0x3000。
  - A是被修正位置的值，即0x00000000。

- 所以最后这个重定位入口修正后地址为：0x3000 +0x00000000 = 0x3000。即指令修正后应该是：

  - ```bash
    ...
    1011: c7 45 f8 64 00 00 00  movl   $0x64,0xfffffff8(%ebp)
    1018: c7 44 24 04 00 30 00  movl   $0x3000,0x4(%esp)
    101f: 00 
    1020: 8d 45 f8              lea 0xfffffff8(%ebp),%eax
    ...
    ```

- 相对寻址修正* 让我们再来看看a.o的第二个重定位入口，即偏移为0x26的这条call指令的修正，它的指令修正方式是R_386_PC32，即相对寻址修正。对于这个重定位入口，它修正后的结果应该是S + A – P。

  - S是符号swap的实际地址，即0x2000；
  - A是被修正位置的值，即0xFFFFFFFC（-4）；
  - P为被修正的位置，当链接成可执行文件时，这个值应该是被修正位置的虚拟地址，即0x1000 + 0x27。

- 所以最后这个重定位入口修正后地址为：0x2000 + (-4) – (0x1000 + 0x27) = 0xFD5。即指令修正后应该是：

  - ```bash
    ...
    1023:  8d 45 f8               lea 0xfffffff8(%ebp),%eax
    1026:  e8 d5 0f 00 00         call   0xfd5
    102b:  89 04 24               mov    %eax,(%esp)
    ...
    2000<swap>:
    ...
    ```

- 这条相对位移调用指令调用的地址是该指令下一条指令的起始地址加上偏移量，即：0x102b + 0xfd5 = 0x2000，刚好是swap函数的地址。

- 从这两个例子可以看出来，绝对寻址修正和相对寻址修正的区别就是绝对寻址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差。





### COMMON 块

- 多符号定义类型不一致的几种情况

  1. 两个或两个以上的强符号类型不一致 (本身就是非法的，链接器会报多重定义错误)

  2. 有一个强符号，其他的都是弱符号，出现类型不一致（如果有一个强符号，则最终输出结果中的符号所占空间与强符号相同）

     - 但是，如果链接过程中有弱符号大小大于强符号，则 ld 会报 warning

     - ```bash
       $ ld: warning: alignment 4 of symbol `global’ in a.o is smaller than 8 in b.o
       ```

     - 

  3. 两个或两个以上弱符号类型不一致

     - 原则上讲，最终连接后输出文件中，变量的大小以输出文件中最大的那个为准

- 回顾问题：在目标文件中，编译器为什么不直接把未初始化的全局变量也当作未初始化的局部静态变量一样处理，为它在BSS段分配空间，而是将其标记为一个COMMON类型的

  - 通过COMMON块机制，可知若编译单元包含了弱符号，则弱符号最终所占空间的大小在此时是未知的
  - 因为有可能其他编译单元中该符号所占的空间比编译单元该符号所占的空间要大，所以编译器此时无法为该弱符号在BSS段分配空间，因为所需要的空间的大小还未知。
  - 当链接器读取所有输入目标文件以后，任何一个弱符号的最终大小都可以确定了，所以它可以在最终输出文件的BSS段为其分配空间。所以总体来看，未初始化全局变量最终还是被放在BSS段的

- 把所有未初始化的全局变量不以COMMON块的形式处理的方法

  - gcc "-fno-common"
  - "\_\_attribute\_\_" 拓展
  - 一旦一个未初始化的全局变量不是以COMMON块的形式存在，那么它就相当于一个强符号，如果其他目标文件中还有同一个变量的强符号定义，链接时就会发生符号重复定义



### C++ 相关问题

#### 重复代码消除

- 产生重复代码的情况
  - Templates
  - Extern Inline Function
  - Virtual Function Table
- 出现的问题
  - 空间浪费
  - 地址容易出错
  - 指令运行效率低
- 一个解决方案
  - 把每个模板的实例代码都单独地存放在一个段里，每个段只包含一个模板实例
- GCC 的实现 叫 "Link Once"，将这种段命名为 ".gnu.linkonce.name"，name是模板函数实例的修饰后的名称
- 这种代码消除方法对于外部内联函数和虚函数表的做法也类似
  - 虚函数表—— Virtual Function Table (一般简称 vtbl，没错，其解决方案就叫虚函数表)
    - 编译器会在用到该类的多个编译单元生成虚函数表，避免造成代码重复
  - 外部内联函数、默认构造函数、默认拷贝构造函数、赋值操作符等也是类似
- 不足
  - 相同的段可能拥有不同的内容，着可能由于不同的编译单元版本或者编译优化选项，导致同一个函数编译出来的实际代码有所不同
  - 此时链接器可能会随机选择其中一个副本作为链接的输入，然后提供一个警告信息

- 函数级别链接
  - 现在的程序或库通常都非常庞大，为了调用某个目标文件中的任意一个变量或者函数时，需要把整个目标文件链接进来，导致输出文件变得非常大
  - VC 提供了一个函数级别链接 (Functional-Level Linking) 的选项
    - 这个选项的作用就是让所有的函数都像前面模板函数一样，单独保存到一个段里面。当链接器须要用到某个函数时，它就将它合并到输出文件中，对于那些没有用的函数则将它们抛弃
    - 但是这个优化选项会减慢编译和链接过程，因为链接器须要计算各个函数之间的依赖关系，并且所有函数都保持到独立的段中，目标函数的段的数量大大增加，重定位过程也会因为段的数目的增加而变得复杂，目标文件随着段数的增加也会变的相对较大
  - GCC 提供了类似的机制， "-ffunction-sections"、"-fdata-sections"
    - 两个选项的作用是将每个函数或变量分别保持在独立的段中

#### 全局构造与析构

- 全局构造函数——main之前执行
- 全局析构函数——main之后执行
- Linux 一般程序的入口时 "_start"，这个函数是Linux系统库 Glibc 的一部分
  - 当我们的程序与Glibc库链接在一起形成最终可执行文件以后，这个函数就是程序的初始
    化部分的入口，程序初始化部分完成一系列初始化过程之后，会调用main函数来执行程序的主体。
  - 在main函数执行完成以后，返回到初始化部分，它进行一些清理工作，然后结束进程。
- 有些场合，程序的一些特定操作必须在main之前执行，还有一些操作必须在main之后执行，比较有代表性的就是全局对象的构造函数与析构函数
- 为解决以上问题，ELF还定义了两个特殊段
- .init 该段里面保存的是可执行指令，它构成了进程的初始化代码。
  - 因此，当一个程序开始运行时，在main函数被调用之前，Glibc的初始化部分安排执行这个段的中的代码。
- .fini 该段保存着进程终止代码指令。因此，当一个程序的main函数正常退出时，Glibc会安排执行这个段中的代码。



#### 静态库链接

... 待续
