###### 从源代码到可执行文件



![alt](https://i.loli.net/2021/10/12/cAkbV6v2xBULmu8.jpg)



#### 预处理 Prepressing


- `hello.c stdio.h` == `cpp` ==> `hello.i`
- `hello.cpp *.hpp` == `cpp` ==> `hello.ii`

```bash
gcc -E hello.c -o hello.i
# -E 之进行预编译

cpp hello.c > hello.i
# 等价
```

- 处理规则
  - 将所有#define 删除, 并展开所有宏定义
  - 处理所有条件与编译指令
    - \#if 、\#ifdef 、\#elif 、\#else、\#endif
  - 处理\#include 预编译指令，将被包含的文件插入到该与编译指令的位置
    - 递归进行，被包含的文件可能包含其他文件
  - 删除注释 `//` 、`/* */`
  - 添加行号和文件标识，比如 `#2"hello.c"2` ，便于编译时编译期产生调试用的行号信息
  - 保留所有 #pragma 编译器指令



#### 编译 Compilation

- 词法分析、语法分析、语义分析、优化后产生相应的汇编代码文件

```bash
gcc -s hello.i -o hello.s
```

- gcc 将预编译和编译合并成一个步骤，用 cc1 程序完成
- cc1 位于 `/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/cc1`

```bash
/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/cc1 hello.c 
# 等效于
gcc -S hello.c -o hello.s
```

- 对于C++来说，用 cc1plus 完成
- cc1plus 位于 ``/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/cc1plus`



#### 汇编 Assembly

- 将汇编代码转变为机器指令

- 只根据汇编指令和机器指令的对照表一一翻译

- ```bash
  as hello.s -o hello.o
  
  gcc -c hello.c -o hello.o
  # 直接从c源代码文件开始，经过预编译、编译、汇编直接输出 Object File
  ```
  
  
  

#### 链接 Linking

- ```bash
  $ld -static /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc/i486-linux-gnu/4.1.3/crtbeginT.o -L/usr/lib/gcc/i486-linux-gnu/4.1.3 -L/usr/lib -L/lib hello.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/i486-linux-gnu/4.1.3/crtend.o /usr/lib/crtn.o
  ```



###  编译

![alt](https://i.loli.net/2021/10/12/P7KcBrqUACVQYvD.jpg)

- 示例代码

  - ```c
    array[index] = (index + 4)*(2 + 6)
    ```

- 词法分析

  - 将源代码字符序列分割成一系列记号Token
  - Token 分类
    - 关键字
    - 标识符
    - 字面量（包含数字、字符串等）
    - 特殊符号（加号、等号等）
  - Scanner 识别记号，并且将标识符存放到符号表、将数字、字符串常量放到文字表待用
  - 

- 语法分析

  - Grammar Parser 对 记号 进行语法分析，产生语法树
  - 分析过程采用了上下文无关语法（Context-free Grammar)
  - 语法分析树是以表达式 Expression 为节点的树
  - ![alt](https://i.loli.net/2021/10/12/yxjOZcDq6FlmQeE.jpg)
  - 语法分析的同时，很多运算符号的优先级和含义也被确定下来
  - 对于具有多重含义的符号（如 *），语法分析阶段对其进行区分
  - 若出现表达式不合法，则会报告语法分析阶段的错误

- 语义分析

  - 语义分析器 Semantic Analyzer
  - 此时分析的语义是静态语义，在编译期可以确定的语义
  - 动态语义是在运行期才能确定的语义
    - 比如0作为除数
  - 静态语义包括声明和类型的匹配、类型的转换
    - 比如浮点型赋给整型，隐含了浮点型到整型的转换过程
  - 经过语义分析后，语法树的表达式标识了类型，若有类型隐式转换，语义分析程序会插入相应的转换节点

- 中间语言

  - 语法树的中间代码 Intermediate Code，是语法树的顺序表示
  - 例如两个常量相加，即可被优化掉，类似的有很多复杂的优化过程

- 目标代码的生成与优化

  - 代码生成器 Code Generator 将中间代码转换为目标机器代码
    - 此过程依赖于目标机器，不同机器有不同的字长、寄存器、整数数据类型、浮点数数据类型等
  - 目标代码优化器 Taget Code Optimizer 对目标机器代码进行优化
    - 选择合适的寻址方式、使用位移来代替乘法运算
    - 删除多余的指令

### 静态链接

- 链接的工作就是把一些指令对其他符号地址的引用加以修正
- 链接过程主要包括
  - 地址和空间分配 Application and Storage Allocation
  - 符号决议 Symbol Resolution
    - 符号决议有时候也被叫做符号绑定（Symbol Binding）、
      名称绑定（Name Binding）、名称决议（Name
      Resolution），甚至还有叫做地址绑定（Address
      Binding）、指令绑定（Instruction Binding）的
  - 重定位 Relocation
    - ![image-20210820105249309](https://i.loli.net/2021/10/12/J4Axy6DolKz1VwP.png)
    - 我们假设A和B链接后，变量var的地址确定下来为0x1000，那么链接器将会把这个指令的目标地址部分修改成0x10000。这个地址修正的过程也被叫做重定位（Relocation），每个要被修正的地方叫一个重定位入口（Relocation Entry）。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正
  - 等

#### 符号决议

- 又称为符号绑定、名称绑定、地址绑定、指令绑定
- ![alt](https://i.loli.net/2021/10/12/OsITwgzE97DnfZp.jpg)

