### 动态链接 Dynamic Linking

- 静态链接的缺点
  - 浪费内存和磁盘空间
    - 每个程序内部除了都保留着printf()函数、scanf()函数、strlen()等这样的公用库函数，还有数量相当可观的其他库函数及它们所需要的辅助数据结构。
    - 保存了多个静态库的副本
    - <img src="https://i.loli.net/2021/10/12/7FoNQjc39BxVpZJ.png" alt="image-20210821075353389" style="zoom:50%;" />
  - 模块更新困难
    - 一旦程序中有任何模块更新，整个程序就要重新链接、发布给用户。
- 动态链接特点
  - 不对那些组成程序得到目标文件进行链接，等待程序要运行时才进行链接
  - 节省内存
  - 减少物理页面的换入换出
  - 增加CPU缓存命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上
  - 程序升级更加容易，只需要将旧的目标文件覆盖掉，而无须把所有的文件重新链接一遍
  - 特点就是程序在运行时可以动态地选择加载各种程序模块（插件）
  - 加强程序兼容性，一个程序在不同平台可以动态链接到由操作系统提供的动态链接库，相当于在程序与OS之间增加了一个中间层
  - 动态链接会导致程序在性能的一些损失，但是对动态链接的链接过程可以进行优化，比如我们后面
    要介绍的延迟绑定（Lazy Binding）等方法，可以使得动态链接的性能损失尽可能地减小。据估算，动态链接与静态链接相比，性能损失大约在5%以下。
- 动态链接涉及运行时的链接及多个文件的装载，必须要有OS的支持
  - 动态链接进程的虚拟地址空间的分布会比静态链接情况更加复杂，还有一些存储管理、内存共享、进程线程等机制
  - Linux 中ELF动态链接文件称为 动态共享对象 DSO, Dynamic Shared Objects ".so"
  - Windows 中 称为 动态链接库 Dynamic Linking Library ".dll"



#### 动态链接例子

```c
/* Program1.c */
#include "Lib.h"
int main()
{   
    foobar(1);
    return 0;
}

/* Program2.c */
#include "Lib.h"
int main()
{   
  foobar(2);
    return 0;
}

/* Lib.c */
#include <stdio.h>
void foobar(int i) 
{
    printf("Printing from Lib.so %d\n", i);
}

/* Lib.h */
#ifndef LIB_H
#define LIB_H
void foobar(int i);
#endif
    
```

```bash
$ gcc -fPIC -shared -o Lib.so lib.c
# 将 Lib.c 编译成一个共享对象文件

$gcc -o Program1 Program1.c ./Lib.so

$gcc -o Program2 Program2.c ./Lib.so

```

![image-20210821081803492](https://i.loli.net/2021/10/12/jTzv3x12dcqaSwn.png)

- 静态链接中，会把Program1.o 和 Lib.o 链接到一起，并产生输出可执行文件 Programm1
  - 在静态链接时，整个程序最终只有一个可执行文件，它是
    一个不可以分割的整体
- 但在动态链接中，Lib.o 没有被链接进来，链接的输出目标文件只有 Program1.o(还有 C 语言运行库)
  - 一个程序被分成了若干个文件，有程序的主要部分，即可执行文件和程序所依赖的共享对象，有时也把这些部分称为模块



- 当Program1.c 被编译成 Program1.o 时，编译器还不知道foobar() 函数的地址
  - 当链接器将 Program1.o 链接成可执行文件时，这时链接器必须确定 Program1.o 中所引用的 foobar() 函数的性质
  - 如果foobar() 是一个定义与其他静态目标模块中的函数
    - 那么链接器会按照静态链接的规则，将 Program1.o 中的 foobar 地址引用重定位
  - 如果foobar() 是一个定义在某个动态共享对象中的函数
    - 那么链接器就会把这个符号的引用标记为一个动态链接的符号，不对其进行地址重定位，把这个过程留到装载时再进行
- 链接器如何知道 foobar 的引用是 静态符号还是动态符号?
  - Lib.so 中保存了完整的符号信息，因为运行时进行动态链接还需要使用符号信息
  - 把 Lib.so 也作为链接的输出文件之一，链接器在解析符号时就可以知道 foobar 是一个定义在 Lib.so 的动态符号，这样链接器就可以对 foobar 的引用做特殊的处理，使其称为一个对动态符号的引用

#### 查看进程地址空间

- 在 Lib.c 的 foobar() 中加入sleep函数，用于使得程序挂起

  - ```c
    #include <stdio.h>
    void foobar(int i)
    {
         printf("Printing from Lib.so %d\n", i);
         sleep(-1);
    }
    ```

  - ```bash
    [sinow@Arch test]$ ./Program1 &
    [1] 4019
    [sinow@Arch test]$ Printing from Lib.so 1
    cat /proc/4019/maps 
    56023153d000-56023153e000 r--p 00000000 103:08 5548746                   /home/sinow/workspace/cpp/test/Program1
    56023153e000-56023153f000 r-xp 00001000 103:08 5548746                   /home/sinow/workspace/cpp/test/Program1
    56023153f000-560231540000 r--p 00002000 103:08 5548746                   /home/sinow/workspace/cpp/test/Program1
    560231540000-560231541000 r--p 00002000 103:08 5548746                   /home/sinow/workspace/cpp/test/Program1
    560231541000-560231542000 rw-p 00003000 103:08 5548746                   /home/sinow/workspace/cpp/test/Program1
    5602332d7000-5602332f8000 rw-p 00000000 00:00 0                          [heap]
    7f43a5b6c000-7f43a5b6f000 rw-p 00000000 00:00 0 
    7f43a5b6f000-7f43a5b95000 r--p 00000000 103:07 7736695                   /usr/lib/libc-2.33.so
    7f43a5b95000-7f43a5ce0000 r-xp 00026000 103:07 7736695                   /usr/lib/libc-2.33.so
    7f43a5ce0000-7f43a5d2c000 r--p 00171000 103:07 7736695                   /usr/lib/libc-2.33.so
    7f43a5d2c000-7f43a5d2f000 r--p 001bc000 103:07 7736695                   /usr/lib/libc-2.33.so
    7f43a5d2f000-7f43a5d32000 rw-p 001bf000 103:07 7736695                   /usr/lib/libc-2.33.so
    7f43a5d32000-7f43a5d3b000 rw-p 00000000 00:00 0 
    7f43a5d4e000-7f43a5d4f000 r--p 00000000 103:08 5548711                   /home/sinow/workspace/cpp/test/Lib.so
    7f43a5d4f000-7f43a5d50000 r-xp 00001000 103:08 5548711                   /home/sinow/workspace/cpp/test/Lib.so
    7f43a5d50000-7f43a5d51000 r--p 00002000 103:08 5548711                   /home/sinow/workspace/cpp/test/Lib.so
    7f43a5d51000-7f43a5d52000 r--p 00002000 103:08 5548711                   /home/sinow/workspace/cpp/test/Lib.so
    7f43a5d52000-7f43a5d53000 rw-p 00003000 103:08 5548711                   /home/sinow/workspace/cpp/test/Lib.so
    7f43a5d53000-7f43a5d55000 rw-p 00000000 00:00 0 
    7f43a5d55000-7f43a5d56000 r--p 00000000 103:07 7736684                   /usr/lib/ld-2.33.so
    7f43a5d56000-7f43a5d7a000 r-xp 00001000 103:07 7736684                   /usr/lib/ld-2.33.so
    7f43a5d7a000-7f43a5d83000 r--p 00025000 103:07 7736684                   /usr/lib/ld-2.33.so
    7f43a5d83000-7f43a5d85000 r--p 0002d000 103:07 7736684                   /usr/lib/ld-2.33.so
    7f43a5d85000-7f43a5d87000 rw-p 0002f000 103:07 7736684                   /usr/lib/ld-2.33.so
    7ffd6d3e5000-7ffd6d406000 rw-p 00000000 00:00 0                          [stack]
    7ffd6d488000-7ffd6d48c000 r--p 00000000 00:00 0                          [vvar]
    7ffd6d48c000-7ffd6d48e000 r-xp 00000000 00:00 0                          [vdso]
    ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
    [sinow@Arch test]$ kill 4019
    
    ```

  - 整个进程虚拟地址空间中，多出了几个文件的映射

  - Lib.so 与 Program1 都是被操作系统用同样的方式映射到进程的虚拟地址空间

  - 除了 Program1 和 Lib.so 外，还用到了动态链接形式的 libc-2.33.so, ld-2.33.so

  - ld-2.33.so就是 Linux 下的动态链接器，动态链接器与普通共享对象一样被映射到了进程的地址空间，在系统开始运行Program1 之前，首先会把控制权交给动态链接器，完成所有的动态链接工作以后再把控制权交给Program1，然后开始执行



- 查看 Lib.so 的装载属性

- ```bash
  [sinow@Arch test]$ readelf -l Lib.so 
  
  Elf file type is DYN (Shared object file)
  Entry point 0x1050
  There are 11 program headers, starting at offset 64
  
  Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                   FileSiz            MemSiz              Flags  Align
    LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x0000000000000570 0x0000000000000570  R      0x1000
    LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                   0x000000000000015d 0x000000000000015d  R E    0x1000
    LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                   0x000000000000009c 0x000000000000009c  R      0x1000
    LOAD           0x0000000000002e10 0x0000000000003e10 0x0000000000003e10
                   0x0000000000000220 0x0000000000000228  RW     0x1000
    DYNAMIC        0x0000000000002e20 0x0000000000003e20 0x0000000000003e20
                   0x00000000000001c0 0x00000000000001c0  RW     0x8
    NOTE           0x00000000000002a8 0x00000000000002a8 0x00000000000002a8
                   0x0000000000000030 0x0000000000000030  R      0x8
    NOTE           0x00000000000002d8 0x00000000000002d8 0x00000000000002d8
                   0x0000000000000024 0x0000000000000024  R      0x4
    GNU_PROPERTY   0x00000000000002a8 0x00000000000002a8 0x00000000000002a8
                   0x0000000000000030 0x0000000000000030  R      0x8
    GNU_EH_FRAME   0x000000000000201c 0x000000000000201c 0x000000000000201c
                   0x000000000000001c 0x000000000000001c  R      0x4
    GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                   0x0000000000000000 0x0000000000000000  RW     0x10
    GNU_RELRO      0x0000000000002e10 0x0000000000003e10 0x0000000000003e10
                   0x00000000000001f0 0x00000000000001f0  R      0x1
  
   Section to Segment mapping:
    Segment Sections...
     00     .note.gnu.property .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
     01     .init .plt .text .fini 
     02     .rodata .eh_frame_hdr .eh_frame 
     03     .init_array .fini_array .dynamic .got .got.plt .data .bss 
     04     .dynamic 
     05     .note.gnu.property 
     06     .note.gnu.build-id 
     07     .note.gnu.property 
     08     .eh_frame_hdr 
     09     
     10     .init_array .fini_array .dynamic .got 
  
  ```

  - 文件类型与普通程序不同
  - 动态链接模块的装在地址是从0x0开始的，这个是无效地址
    - 共享对象的最终装载地址在编译时不确定，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象



### 地址无关代码

### 装载时重定位 Load Time Relocation

- 静态链接也有重定位，不过是 链接时重定位 Link Time Relocation
- 在链接时，对所有绝对地址的引用不做重定位，而推迟到装载时再完成，
  - 一旦模块装载地址确定





