### ELF 格式

- 采用 ELF 格式的文件

| ELF 文件类型                    | 说明                                                         | 实例                                                 |
| ------------------------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| 可重定位文件 Relocatable File   | 包含代码和数据，用来链接成可执行文件或共享目标文件，静态链接库属于此类 | Linux 的.o 文件 ; Windows 的 .obj 文件               |
| 可执行文件 Executable File      | 包含可直接执行的程序，代表为 ELF 可执行文件，一般没有扩展名  | Linux 的 /bin/bash 文件 ; Windosws 的 .exe 文件      |
| 共享目标文件 Shared Object File | 包含了代码和数据。一、链接器可使用这种文件与其他的可重定位文件和共享目录文件链接，产生新的目标文件。二、动态链接器可将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行 | Linux 的 .so ，如 /lib/glibc-2.5.so ; Windows 的 DDL |
| 核心转储文件 Core Dump File     | 当进程意外终止，系统可将该进程的地址空间内容及终止时的一些其他信息转储到核心转储文件 | Linux 下的 core dump 文件                            |

- 可用 file 命令查看相应文件格式

- ```bash
  [sinow@SiMaj ~]$ file /usr/lib/libicuio.so.69.1 
  /usr/lib/libicuio.so.69.1: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=dc3e5944cf30ba4aa85f1b88b7acaf886fd6ca10, stripped
  
  [sinow@SiMaj Test]$ file hello.o 
  hello.o: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=661e09988613722a281fd4bc400dbc28cf964afa, for GNU/Linux 4.4.0, not stripped
  
  [sinow@SiMaj Test]$ file /bin/bash
  /bin/bash: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=db5e646b06a2bed223a36ff75f738217764f4517, for GNU/Linux 3.2.0, stripped
  ```

### 目标文件

- 代码与ELF结构对应
- ![alt](https://i.loli.net/2021/10/12/JrHiSA2CxlUw89a.jpg)

| 中文名 | 名称                          | 描述                                                         |
| ------ | ----------------------------- | ------------------------------------------------------------ |
| 文件头 | File Header                   | 描述了整个文件属性，是否可执行、静态链接还是动态链接、入口地址（若是可执行文件）、目标硬件、目标操作系统等信息 |
| 段表   | Section Table                 | 包含于文件头中，描述了文件中各段在文件中的偏移位置及段的属性等，从段表里面可以得到每个段的所有信息 |
| 代码段 | .code 或 .text                | 机器指令                                                     |
| 数据段 | .data                         | 全局变量和局部静态变量                                       |
|        | .bss(Block Started by Symbol) | 未初始化的全局变量和局部静态变量，默认值均为0；.bss 段只是为未初始化的全局变量和局部静态变量预留位置而已，并没有内容，不占据空间 |
|        | .rodata                       | 只读数据段，一般是程序里面的只读变量（如const修饰的变量）和字符串常量。 |
|        | .comment                      | 注释信息段                                                   |
|        | .note.GNU-stack               | 堆栈提示段                                                   |
|        | .note.gnu.property            |                                                              |
|        | .eh_frame                     |                                                              |
|        | .rodata1                      | 只读数据，比如字符串常量、全局const变量，和 .rodata 一样     |
|        | .debug                        | 调试信息                                                     |
|        | .dynamic                      | 动态链接信息                                                 |
|        | .hash                         | 符号哈希表                                                   |
|        | .line                         | 调试时的行号表，即源代码行号与编译后指令的对应表             |
|        | .note                         | 额外编译器的信息，比如程序的公司名、发布版本号等             |
|        | .strtabl                      | 字符串表，用于存储ELF文件中用到的各种字符串                  |
|        | .shstrtab                     | 段名表                                                       |
|        | .plt  .got                    | 动态链接的跳转表和全局入口表                                 |
|        | .init  .fini                  | 程序初始化与终结代码段                                       |

- `.` 作为前缀，表示这些表的名字是系统保留的
- 应用程序也可以使用一些非系统保留的名字作为段名，但是不可以作为前缀使用`.` ，否则容易和系统保留段名冲突
- 一个ELF文件可以拥有几个相同段名的段，比如 可能具有两个或多个 .text 段 
- 还有一些保留的段名是因为ELF文件历史遗留问题造成的，以前用过的一些名字如.sdata、.tdesc、.sbss、.lit4、.lit8、.reginfo、.gptab、.liblist、.conflict。可以不用理会这些段，它们已经被遗弃了。
- 分段的原因
  - 当程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被分别设置成可读写和只读。这样可以防止程序的指令被有意或无意地改写。
  - 对于现代的CPU来说，它们有着极为强大的缓存（Cache）体系。由于缓存在现代的计算机中地位
    非常重要，所以程序必须尽量提高缓存的命中率。指令区和数据区的分离有利于提高程序的局部性。现代CPU的缓存一般都被设计成数据缓存和指令缓存分离，所以程序的指令和数据被分开存放对CPU的缓存命中率提高有好处
  - 当系统中运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只须要保存一份该程序的指令部分。对于指令这种只读的区域来说是这样，对于其他的只读数据也一样



- SimpleSection.o 剖析 (32位Intel x86)

```c
/* 
 * SimpleSection.c
 * 
 * Linux:
 *   gcc -c SimpleSection.c
 */
int printf( const char* format, ... );

int global_init_var = 84;
int global_uninit_var;

void func1( int i ) 
{
  printf( "%d\n",  i );
}

int main(void)
{
    static int static_var = 85;
 static int static_var2;

    int a = 1;
    int b; 

    func1( static_var + static_var2 + a + b );

    return a; 
}
```

```bash
[sinow@SiMaj Test]$ gcc -c SimpleSection.o
[sinow@SiMaj Test]$ objdump -h SimpleSection.o  # 列出ELF文件中关键的段

SimpleSection.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000057  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000008  0000000000000000  0000000000000000  00000098  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  0000000000000000  0000000000000000  000000a0  2**2
                  ALLOC
  3 .rodata       00000004  0000000000000000  0000000000000000  000000a0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .comment      00000013  0000000000000000  0000000000000000  000000a4  2**0
                  CONTENTS, READONLY
  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000b7  2**0
                  CONTENTS, READONLY
  6 .note.gnu.property 00000030  0000000000000000  0000000000000000  000000b8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .eh_frame     00000058  0000000000000000  0000000000000000  000000e8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

```

- `objdump` 命令列出了段的属性（只有ELF文件中关键的段）

  - CONTENTS 表示该段在文件中存在，
    - bss段实际上并不存在于 ELF 文件中
    - .note.GNU-stack 有CONTENTS属性，但大小为0，暂且认为也不存在
    - 

- ![alt](https://i.loli.net/2021/10/12/2yhCVPXOsSFbvmB.jpg)

- ```bash
  [sinow@SiMaj Test]$ size SimpleSection.o 
     text	   data	    bss	    dec	    hex	filename
      227	      8	      8	    243	     f3	SimpleSection.o
  ```

- objdump -s 可将段的内容以十六进制打开

- ```bash
  [sinow@SiMaj Test]$ objdump -s SimpleSection.o 
  
  SimpleSection.o:     file format elf64-x86-64
  
  Contents of section .text:
   0000 554889e5 4883ec10 897dfc8b 45fc89c6  UH..H....}..E...
   0010 488d3d00 000000b8 00000000 e8000000  H.=.............
   0020 0090c9c3 554889e5 4883ec10 c745f801  ....UH..H....E..
   0030 0000008b 15000000 008b0500 00000001  ................
   0040 c28b45f8 01c28b45 fc01d089 c7e80000  ..E....E........
   0050 00008b45 f8c9c3                      ...E...         
  Contents of section .data:
   0000 54000000 55000000                    T...U...        
  Contents of section .rodata:
   0000 25640a00                             %d..            
  Contents of section .comment:
   0000 00474343 3a202847 4e552920 31302e32  .GCC: (GNU) 10.2
   0010 2e3000                               .0.             
  Contents of section .note.gnu.property:
   0000 04000000 20000000 05000000 474e5500  .... .......GNU.
   0010 020001c0 04000000 00000000 00000000  ................
   0020 010001c0 04000000 01000000 00000000  ................
  Contents of section .eh_frame:
   0000 14000000 00000000 017a5200 01781001  .........zR..x..
   0010 1b0c0708 90010000 1c000000 1c000000  ................
   0020 00000000 24000000 00410e10 8602430d  ....$....A....C.
   0030 065f0c07 08000000 1c000000 3c000000  ._..........<...
   0040 00000000 33000000 00410e10 8602430d  ....3....A....C.
   0050 066e0c07 08000000                    .n...... 
  ```

- GCC提供了一个扩展机制，使得程序员可以指定变量所处的段

  - ```c
    __attribute__ ((section("FOO"))) int global = 42;
    __attribute__ ((section("BAR"))) void foo(){}
    ```



### ELF 文件结构描述

- ELF 文件基本结构图

<img src="https://i.loli.net/2021/10/12/4SydQOmZYLPe58E.jpg" alt="alt" style="zoom:50%;" />



#### 文件头

```bash
[sinow@SiMaj Test]$ readelf -h SimpleSection.o 
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  #ELF魔数
  Class:                             ELF64	#
  Data:                              2's complement, little endian	#数据存储方式
  Version:                           1 (current)	#版本
  OS/ABI:                            UNIX - System V	#运行平台
  ABI Version:                       0	#ABI版本
  Type:                              REL (Relocatable file)	#ELF重定位类型
  Machine:                           Advanced Micro Devices X86-64 # 硬件平台
  Version:                           0x1	#硬件平台版本
  Entry point address:               0x0	入口地址
  Start of program headers:          0 (bytes into file)	#程序头入口
  Start of section headers:          1064 (bytes into file)	#
  Flags:                             0x0	
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0	
  Size of section headers:           64 (bytes)	
  Number of section headers:         14	
  Section header string table index: 13

```

- elf 文件结构在 `/usr/include/elf.h` 中定义

- ELF文件有32位与64位两个版本，其头文件结构也有两个

  - 分别为Elf32_Ehdr、Elf64_Ehdr

- | 自定义类型  | 描述                  | 原始类型 | 长度（字节） |
  | ----------- | --------------------- | -------- | ------------ |
  | Elf32_Addr  | 32 位版本程序地址     | uint32_t | 4            |
  | Elf64_Addr  | 64 位版本程序地址     | uint64_t | 8            |
  | Elf32_Half  | 32 位版本无符号短整型 | uint16_t | 2            |
  | Elf64_Half  | 64 位版本无符号短整型 | uint16_t | 2            |
  | Elf32_Off   | 32 位版本偏移地址     | uint32_t | 4            |
  | Elf64_Off   | 64 位版本偏移地址     | uint64_t | 8            |
  | Elf32_Sword | 32 位版本有符号整型   | uint32_t | 4            |
  | Elf64_Sword | 64 位版本有符号整型   | uint32_t | 4            |
  | Elf32_Word  | 32 位版本无符号整型   | int32_t  | 4            |
  | Elf64_Word  | 64 位版本无符号整型   | int32_t  | 4            |

- 32位版本 Elf32_Ehdr 结构（64与32位除了大小外，其他一致）

- ```c
  typedef struct
  {
    unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
    Elf32_Half	e_type;			/* Object file type */
    Elf32_Half	e_machine;		/* Architecture */
    Elf32_Word	e_version;		/* Object file version */
    Elf32_Addr	e_entry;		/* Entry point virtual address */
    Elf32_Off	e_phoff;		/* Program header table file offset */
    Elf32_Off	e_shoff;		/* Section header table file offset */
    Elf32_Word	e_flags;		/* Processor-specific flags */
    Elf32_Half	e_ehsize;		/* ELF header size in bytes */
    Elf32_Half	e_phentsize;		/* Program header table entry size */
    Elf32_Half	e_phnum;		/* Program header table entry count */
    Elf32_Half	e_shentsize;		/* Section header table entry size */
    Elf32_Half	e_shnum;		/* Section header table entry count */
    Elf32_Half	e_shstrndx;		/* Section header string table index */
  } Elf32_Ehdr;
  ```

- ELF 文件头结构成员含义，更详细内容查看ELF标准文档

- ![](https://i.loli.net/2021/10/12/Vt5URDYmqlndXST.jpg)



- ELF Magic Number
  - ![](https://i.loli.net/2021/10/12/h8ubwEGrH95eqAp.jpg)
  - 最开始的4个字节是所有ELF文件必须相同的标识码
    - 0x7F（ DEL 控制符 ） 0x45（E） 0x4C（L） 0x46（F）
    - 几乎所有可执行文件最开始几个字节都是魔数
  - 第5个字节是标识ELF文件类
  - 第六个字节是大小端
  - 第七个字节是ELF的主版本号，一般是1，因ELF标准自 1.2 以后再也没有更新
  - 后面的9个字节ELF标准没有定义，一般填0，有些平台会使用9个字节作为扩展标识



#### 段表

- 段表是ELF文件中除了文件头以外最重要的结构，

- 描述了ELF的各个段的信息，比如：

  - 每个段的段名
  - 段的长度
  - 在文件中的偏移
  - 读写权限
  - 段的其他属性
  
- ELF文件的段结构就是由段表决定的

- 编译器、连接器、装载器 依靠段表来定位和访问各个段的属性

- 段表在ELF文件中的位置由文件头的 `e_shoff` 成员决定，

- `readelf -S` 显示出ELF文件中真正的段表结构

- ```bash
  [sinow@SiMaj Test]$ readelf -S SimpleSection.o 
  There are 14 section headers, starting at offset 0x428:
  
  Section Headers:
    [Nr] Name              Type             Address           Offset
         Size              EntSize          Flags  Link  Info  Align
    [ 0]                   NULL             0000000000000000  00000000
         0000000000000000  0000000000000000           0     0     0
    [ 1] .text             PROGBITS         0000000000000000  00000040
         0000000000000057  0000000000000000  AX       0     0     1
    [ 2] .rela.text        RELA             0000000000000000  00000308
         0000000000000078  0000000000000018   I      11     1     8
    [ 3] .data             PROGBITS         0000000000000000  00000098
         0000000000000008  0000000000000000  WA       0     0     4
    [ 4] .bss              NOBITS           0000000000000000  000000a0
         0000000000000008  0000000000000000  WA       0     0     4
    [ 5] .rodata           PROGBITS         0000000000000000  000000a0
         0000000000000004  0000000000000000   A       0     0     1
    [ 6] .comment          PROGBITS         0000000000000000  000000a4
         0000000000000013  0000000000000001  MS       0     0     1
    [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000b7
         0000000000000000  0000000000000000           0     0     1
    [ 8] .note.gnu.pr[...] NOTE             0000000000000000  000000b8
         0000000000000030  0000000000000000   A       0     0     8
    [ 9] .eh_frame         PROGBITS         0000000000000000  000000e8
         0000000000000058  0000000000000000   A       0     0     8
    [10] .rela.eh_frame    RELA             0000000000000000  00000380
         0000000000000030  0000000000000018   I      11     9     8
    [11] .symtab           SYMTAB           0000000000000000  00000140
         0000000000000150  0000000000000018          12     8     8
    [12] .strtab           STRTAB           0000000000000000  00000290
         0000000000000076  0000000000000000           0     0     1
    [13] .shstrtab         STRTAB           0000000000000000  000003b0
         0000000000000074  0000000000000000           0     0     1
  Key to Flags:
    W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
    L (link order), O (extra OS processing required), G (group), T (TLS),
    C (compressed), x (unknown), o (OS specific), E (exclude),
    l (large), p (processor specific)
  
  ```

- 段表的结构是以`Elf32_Shadr` 结构体为元素的数组（结构定义在 /usr/include/elf.h？）

- ```c
  typedef struct
  {
    Elf32_Word    sh_name;
    Elf32_Word    sh_type;
    Elf32_Word    sh_flags;
    Elf32_Addr    sh_addr;
    Elf32_Off     sh_offset;
    Elf32_Word    sh_size;
    Elf32_Word    sh_link;
    Elf32_Word    sh_info;
    Elf32_Word    sh_addralign;
    Elf32_Word    sh_entsize;
  } Elf32_Shdr;
  ```

- ![](https://i.loli.net/2021/10/12/MzgDEPWt5JL9By6.jpg)

- 数组元素的个数等于段的个数，每一个结构体对应一个段

- `Elf32_Shdr` 又被称为段描述符（Section Descriptor）

- ELF段表的第一个元素是无效的段描述符，类型为`NULL`

- ELF 文件中多处采用了与段表类似的数组方式保存，一般定义一个固定长度的结构，依次存放，随机存取

- 段的名字对于编译器、链接器来说有意义，对于OS没有实质意义

  - 对于OS来说，一个段如何处理取决于其段的类型与标志位

- 根据的出了 SimpleSection 完整段结构（为何与实际有出入？）

- SectionTable长度为0x1b8，也就是440个字节，

  - 它包含了11个段描述符，每个段描述符为40个字节，这个长度刚好等于sizeof(Elf32_Shdr)，符合段描述符的结构体长度；

- 整个文件最后一个段“.rel.text”结束后，长度为0x450，即1104字节，即刚好是SimpleSection.o的文件长度。

- 中间Section Table和“.rel.text”都因为对齐的原因，与前面的段之间分别有一个字节和两个字节的间隔。

- <img src="https://i.loli.net/2021/10/12/xbqgIX8TDGinvyJ.jpg" style="zoom:50%;" />



- 段的名字只在链接和编译过程中有意义，不能真正表示段的类型

- 对于编译器和连接器，主要决定段属性的是段的类型( sh_type )与段的标志位( sh_flags )

- 段的类型常量

- | 常量         | 值   | 含义                        |
  | ------------ | ---- | --------------------------- |
  | SHT_NULL     | 0    | 无效段                      |
  | SHT_PROGBITS | 1    | 程序段。包括代码段与数据段  |
  | SHT_SYMTAB   | 2    | 表示该段的内容为符号表      |
  | SHT_STRTAB   | 3    | 内容为字符串表              |
  | SHT_RELA     | 4    | 重定位表，包含了重定位信息  |
  | SHT_HASH     | 5    | 符号的哈希表                |
  | SHT_DYNAMIC  | 6    | 动态链接信息                |
  | SHT_NOTE     | 7    | 提示性信息                  |
  | SHT_NOBITS   | 8    | 该段在文件中没内容，如 .bss |
  | SHT_REL      | 9    | 包含重定位信息              |
  | SHT_SHLIB    | 10   | 保留                        |
  | SHT_DNYSYM   | 11   | 动态链接符号表              |

  

- 标志位表示该段在进程虚拟地址空间中的属性

- | 常量          | 值   | 含义                                                    |
  | ------------- | ---- | ------------------------------------------------------- |
  | SHF_WRITE     | 1    | 该段在进程空间中可写                                    |
  | SHF_ALLOC     | 2    | 该段在进程空间中需要分配空间，如代码段、数据段、.bss 段 |
  | SHF_EXECINSTR | 4    | 该段在进程空间可执行，一般指代码段                      |



- 对于系统保留段，列举其属性

- | Name      | sh_type      | sh_flag                                                      |
  | --------- | ------------ | ------------------------------------------------------------ |
  | .bss      | SHT_NOBITS   | SHF_ALLOC + SHF_WRITE                                        |
  | .comment  | SHT_PROGBITS | NONE                                                         |
  | .data     | SHT_PROGBITS | SHF_ALLOC + SHF_WRITE                                        |
  | .data1    | SHT_PROGBITS | SHF_ALLOC + SHF_WRITE                                        |
  | .debug    | SHT_PROGBITS | NONE                                                         |
  | .dynamic  | SHT_DYNAMIC  | SHF_ALLOC + SHF_WRITE 有些系统下 .dynamic 段是只读的，没有SHF_WRITE 位 |
  | .hash     | SHT_HASH     | SHF_ALLOC                                                    |
  | .line     | SHT_PROGBITS | NONE                                                         |
  | .note     | SHT_NOTE     | NONE                                                         |
  | .rodata   | SHT_PROGBITS | SHF_ALLOC                                                    |
  | .rodata1  | SHT_PROGBITS | SHF_ALLOC                                                    |
  | .shstrtab | SHT_STRTAB   | NONE                                                         |
  | .strtab   | SHT_STRTAB   | 若该ELF文件中有可装载的段必须要用到字符串表，则字符串表也将被装载到进程空间，有 SHF_ALLOC 位 |
  | .symtab   | SHT_SYMTAB   | 同字符串表                                                   |
  | .text     | SHT_PROGBITS | SHF_ALLOC + SHF_EXECINSTR                                    |



- 若段类型是与链接相关的，比如重定位表、符号表，

- 则sh_link sh_info 两成员的意义为（其他类型的段，该两个成员没有意义）：

- | sh_type     | sh_link                            | sh_info                          |
  | ----------- | ---------------------------------- | -------------------------------- |
  | SHT_DYNAMIC | 该段使用的字符串表在段表的下标     | 0                                |
  | SHT_HASH    | 该段使用的字符串表在段表的下标     | 0                                |
  | SHT_REL     | 该段所使用的相应符号表在段表的下标 | 该重定位表作用的段在段表中的下标 |
  | SHT_RELA    | 该段所使用的相应符号表在段表的下标 | 该重定位表作用的段在段表中的下标 |
  | SHT_SYMTAB  | 操作系统相关                       | 操作系统相关                     |
  | SHT_DYNSYM  | 操作系统相关                       | 操作系统相关                     |
  | other       | SHN_UNDEF                          | 0                                |





#### 重定位表

- 链接器在处理目标文件时，须对目标文件中的某些部位进行重定位
  - 即代码段和数据段中那些对绝对地址的引用的位置
  - 此类重定位信息记录在ELF文件的重定位表中
  - 每个需要重定位的代码段或数据段，都会有一个相应的重定位表
    - 如 .rel.text ===> .text ;  .rel.data ===> .rel.data
- 一个重定位表也是ELF文件的一个段，类型为 SHT_REL
- sh_link 表示符号表的下标
- sh_info 表示作用于哪个段
  - 如 .rel.text 作用于 .text 段，其中 .text 下标为 1，则 .rel.text 的sh_info 为 1



#### 字符串表

- 示例字符串表

| 偏移 | +0   | +1   | +2   | +3   | +4   | +5   | +6   | +7   | +8   | +9   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +0   | \0   | h    | e    | l    | l    | o    | w    | o    | r    | l    |
| +10  | d    | \0   | M    | y    | v    | a    | r    | i    | a    | b    |
| +20  | l    | e    | \0   |      |      |      |      |      |      |      |

- 对应字符串

| 偏移 | 字符串     |
| ---- | ---------- |
| 0    | null       |
| 1    | helloworld |
| 6    | world      |
| 12   | Myvariable |



- 两种字符串表
  - 字符串表（String Table） .strtab
    - 保存普通字符串
  - 段表字符串表（Section Header String） .shstrtab
    - 保存段表用到的字符串，如段名（ sh_name ）
- ELF 文件头中有 `e_shstrndx` ，是Elf32_Ehdr 的最后一个成员，表示 .shstrtab 在段表中的下标
  - 前面 SimpleSection.o 中， e_shstrndx 值为 8， 根据 readelf -S 的结果可知， .shstrtab 刚好位于段表中的下标为 8 的位置上
  - 只要分析 ELF 文件头，就可以得到 段表 和 段表字符串表 的位置，进而解析整个文件





### 链接的接口——符号

- 每个目标文件都会有一个相应的符号表（Symbol Table），记录了该文件所用到的所有符号
- 每一个符号对应一个符号值（Symbol Value）
- 对于变量和函数，符号值即其地址

| 类型                         | 描述                                                   | 举例                                                         |
| ---------------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| 定义在本目标文件中的全局符号 | 可被其他目标文件引用                                   | 如SS.o 中的 func1 main global_init_var                       |
| 外部符号                     | 本目标文件引用的未定义在本文件的全局符号，也叫符号引用 | 如 SS.o 的 printf                                            |
| 段名                         | 由编译器产生，该值即该段的起始地址                     | 如 SS.o 的 .text .data                                       |
| 局部符号                     | 只在编译单元内部可见                                   | 如 SS.o 的 static_var static_var2，可食用此类符号分析程序或核心转储文件。对链接过程没有作用，链接器常常忽略 |
| 行号信息                     | 目标文件指令与源代码中代码行的对应关系，可选           |                                                              |

- 最值得关注的是 定义在本文件全局符号 与 外部符号，因链接过程只关心全局符号的相互粘合

- readelf objdump nm 均可查看ELF文件的符号表

- ```bash
  [sinow@SiMaj Test]$ nm SimpleSection.o 
  0000000000000000 T func1
  0000000000000000 D global_init_var
                   U _GLOBAL_OFFSET_TABLE_
  0000000000000000 B global_uninit_var
  0000000000000024 T main
                   U printf
  0000000000000004 d static_var.1
  0000000000000004 b static_var2.0
  ```

#### 符号表结构

- 符号表是文件的一个段，段名一般为 .symtab

- 结构是一个Elf32_Sym结构的一个数组

- ```c
  typedef struct
  {
    Elf32_Word	st_name;		/* Symbol name (string tbl index) */
    Elf32_Addr	st_value;		/* Symbol value */
    Elf32_Word	st_size;		/* Symbol size */
    unsigned char	st_info;		/* Symbol type and binding */
    unsigned char	st_other;		/* Symbol visibility */
    Elf32_Section	st_shndx;		/* Section index */
  } Elf32_Sym;
  ```

- 每个结构对应一个符号

- 第一个元素，0 号元素是无效的 未定义符号

- ![](https://i.loli.net/2021/10/12/2CjvnQzaSDpAE3I.jpg)

- 符号类型和绑定信息st_info 

- 该成员低4位表示符号的类型 Symbol Type，高28位表示符号的绑定信息 Symbol Binding

- 符号类型

- | 宏定义名    | 值   | 说明                                                         |
  | ----------- | ---- | ------------------------------------------------------------ |
  | STT_NOTYPE  | 0    | 未知类型                                                     |
  | STT_OBJECT  | 1    | 该符号是个数据对象，如变量、数组等                           |
  | STT_FUNC    | 2    | 该符号是个函数或其他可执行代码                               |
  | STT_SECTION | 3    | 该符号是一个段，这种符号必须是STB_LOCAL                      |
  | STT_FILE    | 4    | 该符号表示文件名，一般都是该目标文件所对应的源文件名，一定是STB_LOCAL 的，其 st_shndx 一定是 SHN——ABS |

- 

- 符号绑定信息

- | 宏定义名   | 值   | 说明                     |
  | ---------- | ---- | ------------------------ |
  | STB_LOCAL  | 0    | 局部符号，对于外部不可见 |
  | STB_GLOBAL | 1    | 全局符号，外部可见       |
  | STB_WEAK   | 2    | 弱引用                   |



- 如果符号定义在本目标文件中，则 st_shndx 表示符号所在的段在段表中的下标

- 但若符号不是定义在本目标文件中，或对于有些特殊符号， st_shndx 有些特殊：

- | 宏定义名   | 值     | 说明                                                         |
  | ---------- | ------ | ------------------------------------------------------------ |
  | SHN_ABS    | 0xfff1 | 表示该符号包含了一个绝对的值。如表示文件名的符号             |
  | SHN_COMMON | 0xfff2 | 表示该符号是一个 COMMON 块 类型的符号，一般为初始化全局符号定义就是这种类型。如 SS.o 的 global_uninit_var |
  | SHN_UNDEF  | 0      | 表示该符号未定义，该符号在本目标文件被引用到，但定义在其他目标文件中 |



- 符号值分类

- | 类型                     | 说明                                                         | 举例                                    |
  | ------------------------ | ------------------------------------------------------------ | --------------------------------------- |
  | 目标文件中，不是COMMON块 | 即st_shndx 不为 SHN_COMMON，则st_value 表示该符号在段中的偏移。即符号所对应的函数或变量位于 st_shndx 指定的段，偏移 st_value 的位置，最常见情况 | 如 SS.o 中的 fucn1 main global_init_var |
  | 目标文件中，是COMMON块   | 即st_shndx 为 SHN_COMMON，则 st_value 表示该符号的对其属性   | 如 SS.o 中的 global_uninit_var          |
  | 可执行文件中             | st_value 表示符号的虚拟地址，对动态链接器十分有用            |                                         |



- 分析各个符号在符号表中的状态

- ```c
  [sinow@SiMaj Test]$ readelf -s SimpleSection.o 
  
  Symbol table '.symtab' contains 14 entries:
     Num:    Value          Size Type    Bind   Vis      Ndx Name
       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
       1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS SimpleSection.c
       2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
       3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
       4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
       5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 
       6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_var.1
       7: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 static_var2.0
       8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_init_var
       9: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_uninit_var
      10: 0000000000000000    36 FUNC    GLOBAL DEFAULT    1 func1
      11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
      12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
      13: 0000000000000024    51 FUNC    GLOBAL DEFAULT    1 main
  
  ```

- 标头含义

  - Num：符号表数组下标
  - Value：符号值，即 st_value
  - Size：符号大小，即 st_size
  - Type：符号类型
  - Bind：绑定信息
  - Vis：在C/C++ 中未使用，暂时忽略
  - Ndx：符号所属的段，即 st_shndx
  - Name：符号名称

- 符号解释

  - func1 main 均为处于代码段，Ndx = 1,即 .text 下标为 1

    - 均为函数，类型为 STT_FUNC
    - 全局可见，STB_GLOBAL
    - Size 表示函数指令所占字节数
    - Value 表示函数相对于代码段起始位置的偏移量

  - printf 在SS.o 中被引用，但没有被定义，所以 Ndx 是SHN_UNDEF

  - global_init_var 为一初始化全局变量，被定义在 .bss 段

  - global_uninit_var 为一未初始化全局变量，是一个 SHN_COMMON 类型符号，本身并没有存在于BSS段，详情了解 COMMON 块

  - static_var.1 static_var2.0 是两个静态变量，绑定属性为 STB_LOCAL ，仅编译单元内部可见

  - SimpleSection.c 即表示编译单元的源文件名

  - 对于类型为 STT_SECTION 的符号，表示下标为 Ndx 的段名。

    - 其符号名未显示，其符号名即为其段名

    - 如 2 号符号 Ndx 为 1,则其表示 .text 段的段名，可用 objdump -t 查看

    - ```c
      [sinow@SiMaj Test]$ objdump -t SimpleSection.o 
      
      SimpleSection.o:     file format elf64-x86-64
      
      SYMBOL TABLE:
      0000000000000000 l    df *ABS*	0000000000000000 SimpleSection.c
      0000000000000000 l    d  .text	0000000000000000 .text
      0000000000000000 l    d  .data	0000000000000000 .data
      0000000000000000 l    d  .bss	0000000000000000 .bss
      0000000000000000 l    d  .rodata	0000000000000000 .rodata
      0000000000000004 l     O .data	0000000000000004 static_var.1
      0000000000000004 l     O .bss	0000000000000004 static_var2.0
      0000000000000000 g     O .data	0000000000000004 global_init_var
      0000000000000000 g     O .bss	0000000000000004 global_uninit_var
      0000000000000000 g     F .text	0000000000000024 func1
      0000000000000000         *UND*	0000000000000000 _GLOBAL_OFFSET_TABLE_
      0000000000000000         *UND*	0000000000000000 printf
      0000000000000024 g     F .text	0000000000000033 main
      ```

  - 特殊符号

    - 链接器在产生可执行文件时，会定义很多特殊符号，未在程序中定义，但可以直接声明并引用，这些符号是定义在 ld 链接器的链接脚本中的，称为特殊符号

    - 无需定义，直接声明并使用

    - 只有使用ld链接产生最终可执行文件的时候这些符号才会存在

    - 代表性特殊符号

    - | 符号                 | 说明                                 |
      | -------------------- | ------------------------------------ |
      | _executable_start    | 程序起始位置，不是入口地址           |
      | __etext _etext etext | 代码段结束地址，即代码段最末尾的地址 |
      | _edata edata         | 数据段结束地址，数据段最末尾的地址   |
      | _end end             | 程序结束地址                         |

    - 地址均为虚拟地址

    - ```c
       /*
       * SpecialSymbol.c
       */
      #include <stdio.h>
      
      extern char __executable_start[];
      extern char etext[], _etext[], __etext[];
      extern char edata[], _edata[];
      extern char end[], _end[];
      
      
      int main()
      {
          printf("Executable Start %X\n", __executable_start);
          printf("Text End %X %X %X\n", etext, _etext, __etext);
          printf("Data End %X %X\n", edata, _edata);
          printf("Executable End %X %X\n", end, _end);
      
          return 0;
      }
      ```

    - ```bash
      [sinow@SiMaj Test]$ gcc SpecialSymbol.c -o SpecialSymbol
      [sinow@SiMaj Test]$ ./SpecialSymbol 
      Executable Start 7F736000
      Text End 7F737245 7F737245 7F737245
      Data End 7F73A030 7F73A030
      Executable End 7F73A038 7F73A038
      ```

  - 签名修饰机制

    - 函数签名包含了函数名、参数类型、所在的类、命名空间 等其他信息

    - 编译器、链接器处理符号时，用某种名称修饰方法，使每个函数签名对应一个修饰后的名称

    - 编译器在将源代码编译成目标文件时，会将函数和变量的名字进行修饰，形成符号名

    - 编译器和链接器都是用符号来识别和处理函数和变量

    - 例程

    - ```c++
      int func(int);
      float func(float);
      
      class C {
          int func(int);
          class C2 {
              int func(int);
          };
      };
      
      namespace N {
          int func(int);
          class C {
              int func(int);
          };
      }
      ```

    - 函数签名 对应 符号名

    - ![](https://i.loli.net/2021/10/12/eJZWtAMNkuTDa34.jpg)

    - GCC 修饰 C++ 函数签名方法

      1. 所有符号以 _Z 开头
      2. 若是嵌套（命名空间或类里面），则跟 N
      3. 然后是 命名空间 或 类 的名字
      4. 名字字符串长度
      5. 函数名字
      6. 以 E 结尾
      
      - 对于函数来说，参数列表紧跟在 E 后面
      - 若是 int 则跟 i
      
    - binutils 提供了 c++filt 工具来解析被修饰过的名称，比如
    
      - $ c++filt _ZN1N1C4funcEi N::C::func(int)
    
    - 签名和修饰在C++ 中的全局变量、静态变量也有同样的应用
    
      - 全局变量：
        - 和函数一样都是全局可见名称，也遵循上述的机制
        - 如： foo 命名空间的 全局变量 bar ===> _ZN3foo3barE
        - 不包含变量类型
      - 静态变量：
        - 如 main() 中 静态变量 foo，func() 中 静态变量 foo
        - 修饰为：_ZZ4mainE3foo ， __ZZ4funcvE3foo
    
  - extern "C"

    - C++ 为了与C兼容

    - ```c++
      extern ”C” {
          int func(int);
          int var;
      }
      ```

    - 将大括号内部作为 C 来处理，则C++等名称修饰机制不会起作用

    - 大括号里边的符号都为修饰后符号，即前面不用加下划线

    - 若要单独声明某函数或某变量为 C 语言符号，可采用

    - ```C
      extern "C" int func(int);
      extern "C" int var;
      ```

    - 实验：（代码无法编译成功）

    - ```c++
      #include <stdio.h>
      
      namespace myname {
          int var = 42; 
          //myname 空间里定义一个全局变量 var
      }
      
      extern "C" int _ZN6myname3varEi;
      //根据GCC修饰规则，得出 var 修饰后的名称 _ZN6myname3varEi
      
      int main()
      {
          printf( "%d\n", _ZN6myname3varEi );
          return 0;
      }
      ```

    - ```bash
      $ g++ ManaulNameMangling.cpp –o ManualNameMangling
      $ ./ManualNameMangling
      42
      ```

    - C++ 宏 `__cplusplus` 来判断当前是不是 C++ 代码

    - C++ 编译器在编译 C++程序时默认定义这个宏

    - ```c
      #ifdef __cplusplus
      extern "C" {
      #endif
       
      void *memset (void *, int, size_t);
      
      #ifdef __cplusplus
      }
      #endif
      ```

    - 如果当前编译单元是C++代码，那么memset会在extern “C”里面被声明；

    - 如果是C代码，就直接声明。

    - 上面这段代码中的技巧几乎在所有的系统头文件里面都被用到

  - 弱符号、强符号

    - 多个目标文件中含有相同名字的全局符号定义，这些文件链接时会报错

    - ```bash
      b.o:(.data+0x0): multiple definition of `global'
      a.o:(.data+0x0): first defined here
      ```

    - 编译器默认函数和初始化了的全局变量为强符号

    - 未初始化的全局变量为弱符号

    - 可通过 gcc 的 \_\_attribute\_\_((weak)) 来定义任何一个强符号为弱符号

    - 强弱符号是针对定义来说的，不是针对符号的引用

    - ```c
      extern int ext; 
      int weak; //弱
      int strong = 1; //强
      __attribute__((weak)) weak2 = 2; //弱
      
      int main()
      {
      	return 0;
      }
      ```

    - 选择多次被定义的全局符号 处理规则

      1. 不允许强符号被多次定义，链接器会报 符号重复定义错误
      2. 一个符号在某目标文件中是强符号，其他文件中是弱符号，则选择强符号
      3. 一个符号在所有目标文件中是弱符号，选择占用空间最大的一个
         - 如： int double ==> double
         - 尽量不要使用多个不同类型的弱符号，否则容易导致很难发现的程序错误

  - 强引用、弱引用

    - 强引用：没有找到该符号的定义会报符号为定义错误

    - 弱引用：没有找到该符号的定义，不报错，默认其为 0 或是 一个特殊的值

    - GCC 中通过使用 \_\_attribute\_\_((weakref)) 来声明一个外部函数为弱引用

    - ```c
      __attribute__ ((weakref)) void foo();
      
      int main()
      {
          foo();
      }
      ```

    - 编译不会报错，执行时会发生运行错误，因 foo 地址为0, 试图调用 foo 函数时，会发生非法地址访问的错误

    - ```c
      __attribute__ ((weakref)) void foo();
      
      int main()
      {
          if(foo) foo();
      }
      ```

    - 对库来说十分有用

    - 库中弱符号可以被用户定义的强符号所覆盖，使得程序可以使用自定义版本的库函数

    - 程序对扩展模块弱引用

    - 通过弱引用来判断当前程序是链接到了单线程的Glibc库 还是 多线程Glibc库（是否在编译时有 -lpthread 选项）

    - ```c
      #include <stdio.h>
      #include <pthread.h>
      
      int pthread_create(
      pthread_t*, 
          const pthread_attr_t*, 
          void* (*)(void*), 
          void*) __attribute__ ((weak));
      //没看明白
      
      int main()
      {
          if(pthread_create) {
              printf("This is multi-thread version!\n");
              // run the multi-thread version
              // main_multi_thread()
          } else {
              printf("This is single-thread version!\n");    
              // run the single-thread version
              // main_single_thread()
          }
      }
      ```

    - ```bash
      [sinow@SiMaj Test]$ gcc pthread.c -o pt
      [sinow@SiMaj Test]$ ./pt
      This is single-thread version!
      [sinow@SiMaj Test]$ gcc pthread.c -lpthread -o pt
      [sinow@SiMaj Test]$ ./pt
      This is multi-thread version!
      [sinow@SiMaj Test]$ 
      ```

    - 


- 调试信息

  - 使用GCC 编译时加上 -g 参数，会在产生的目标文件中加上调试信息

  - 通过readelf 等工具可以看到目标文件里多了很多 debug 相关段

  - ```bash
    [sinow@SiMaj Test]$ gcc -c -g SimpleSection.c 
    [sinow@SiMaj Test]$ readelf -S SimpleSection.o 
    There are 22 section headers, starting at offset 0x910:
    
    Section Headers:
      [Nr] Name              Type             Address           Offset
           Size              EntSize          Flags  Link  Info  Align
      [ 0]                   NULL             0000000000000000  00000000
           0000000000000000  0000000000000000           0     0     0
      [ 1] .text             PROGBITS         0000000000000000  00000040
           0000000000000057  0000000000000000  AX       0     0     1
      [ 2] .rela.text        RELA             0000000000000000  000005a8
           0000000000000078  0000000000000018   I      19     1     8
      [ 3] .data             PROGBITS         0000000000000000  00000098
           0000000000000008  0000000000000000  WA       0     0     4
      [ 4] .bss              NOBITS           0000000000000000  000000a0
           0000000000000008  0000000000000000  WA       0     0     4
      [ 5] .rodata           PROGBITS         0000000000000000  000000a0
           0000000000000004  0000000000000000   A       0     0     1
      [ 6] .debug_info       PROGBITS         0000000000000000  000000a8
           000000000000008a  0000000000000000   C       0     0     8
      [ 7] .rela.debug_info  RELA             0000000000000000  00000620
           00000000000001b0  0000000000000018   I      19     6     8
      [ 8] .debug_abbrev     PROGBITS         0000000000000000  00000138
           000000000000007c  0000000000000000   C       0     0     8
      [ 9] .debug_aranges    PROGBITS         0000000000000000  000001b8
           000000000000002f  0000000000000000   C       0     0     8
      [10] .rela.debug_[...] RELA             0000000000000000  000007d0
           0000000000000030  0000000000000018   I      19     9     8
      [11] .debug_line       PROGBITS         0000000000000000  000001e7
           000000000000005d  0000000000000000           0     0     1
      [12] .rela.debug_line  RELA             0000000000000000  00000800
           0000000000000018  0000000000000018   I      19    11     8
      [13] .debug_str        PROGBITS         0000000000000000  00000248
           000000000000009d  0000000000000001 MSC       0     0     8
      [14] .comment          PROGBITS         0000000000000000  000002e5
           0000000000000013  0000000000000001  MS       0     0     1
      [15] .note.GNU-stack   PROGBITS         0000000000000000  000002f8
           0000000000000000  0000000000000000           0     0     1
      [16] .note.gnu.pr[...] NOTE             0000000000000000  000002f8
           0000000000000030  0000000000000000   A       0     0     8
      [17] .eh_frame         PROGBITS         0000000000000000  00000328
           0000000000000058  0000000000000000   A       0     0     8
      [18] .rela.eh_frame    RELA             0000000000000000  00000818
           0000000000000030  0000000000000018   I      19    17     8
      [19] .symtab           SYMTAB           0000000000000000  00000380
           00000000000001b0  0000000000000018          20    12     8
      [20] .strtab           STRTAB           0000000000000000  00000530
           0000000000000076  0000000000000000           0     0     1
      [21] .shstrtab         STRTAB           0000000000000000  00000848
           00000000000000c3  0000000000000000           0     0     1
    Key to Flags:
      W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
      L (link order), O (extra OS processing required), G (group), T (TLS),
      C (compressed), x (unknown), o (OS specific), E (exclude),
      l (large), p (processor specific)
    
    ```

  - 调试信息往往比程序代码和数据大好几倍，可用 strip 命令去掉 ELF文件 调试信息（还有一些其他段）

  - ```bash
    gcc: error: unrecognized command-line option ‘-cs’; did you mean ‘-Os’?
    [sinow@SiMaj Test]$ strip SimpleSection.o 
    [sinow@SiMaj Test]$ readelf -S SimpleSection.o 
    There are 10 section headers, starting at offset 0x1a0:
    
    Section Headers:
      [Nr] Name              Type             Address           Offset
           Size              EntSize          Flags  Link  Info  Align
      [ 0]                   NULL             0000000000000000  00000000
           0000000000000000  0000000000000000           0     0     0
      [ 1] .text             PROGBITS         0000000000000000  00000040
           0000000000000057  0000000000000000  AX       0     0     1
      [ 2] .data             PROGBITS         0000000000000000  00000098
           0000000000000008  0000000000000000  WA       0     0     4
      [ 3] .bss              NOBITS           0000000000000000  000000a0
           0000000000000008  0000000000000000  WA       0     0     4
      [ 4] .rodata           PROGBITS         0000000000000000  000000a0
           0000000000000004  0000000000000000   A       0     0     1
      [ 5] .comment          PROGBITS         0000000000000000  000000a4
           0000000000000013  0000000000000001  MS       0     0     1
      [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000b7
           0000000000000000  0000000000000000           0     0     1
      [ 7] .note.gnu.pr[...] NOTE             0000000000000000  000000b8
           0000000000000030  0000000000000000   A       0     0     8
      [ 8] .eh_frame         PROGBITS         0000000000000000  000000e8
           0000000000000058  0000000000000000   A       0     0     8
      [ 9] .shstrtab         STRTAB           0000000000000000  00000140
           000000000000005a  0000000000000000           0     0     1
    Key to Flags:
      W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
      L (link order), O (extra OS processing required), G (group), T (TLS),
      C (compressed), x (unknown), o (OS specific), E (exclude),
      l (large), p (processor specific)
    
    ```

  - 

