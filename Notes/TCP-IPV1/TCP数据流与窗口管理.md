# TCP数据流与窗口管理

## 交互式通信

- 该连接需要在客户端与服务器之间传输用户信息，如按键操作、短消息、操作杆或鼠标的滑动等

  - 如果采用较小的报文段承载这些用户信息，则传输协议需要耗费很高的代价，因为每个交换分组中包含的有效负载字节较小

  - 反之，报文段较大则会引入更大的延时，对延迟敏感类应用，造成负面影响

### 以 SSH 为例

- ssh每次交互按键通常都会生成一个单独的数据包，且ssh会在远程系统服务端调用一个shell，对客户端的输入字符做回显
- 每次输入的字符会生成4个TCP数据段
  - 客户端的交互击键输入
  - 服务端对击键的确认
  - 服务端生成的回显
  - 客户端对该回显的确认
- <img src="https://i.loli.net/2021/10/12/KBqyWxTY9D6M12p.png" alt="image-20210905142431389" style="zoom:50%;" />



## 延时确认

- 累计确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传的数据结合发送
- 这种捎带传输的方法经常用于批量数据传输
- 延时ACK的方法会减少ACK传输数目，可以一定程度上减轻网络负担
- 对于批量数据传输通常为2：1的比例
- 延迟发送ACK的最大时延可以动态配置
- Linux采用了一种动态调节算法
  - 可以在每个报文段返回一个 ACK 与 传统延时ACK模式之间相互切换
- 通常TCP 在某些情况下使用延时A C K 的方法, 但时延不会很长在小数据包传输中, 如交互式应用, 需要采用另外的算法。将该算法与延时ACK 结合使用, 如果处理不好, 反而会导致性能降低。



## Nagle 算法

- ssh连接中，通常单次击键就会引发数据流的传输
  - 如果使用IPv4，则一次按键会生成约88字节大小的TCP/IPv4包（使用加密和认证）：20字节的IP头部，20字节的TCP头部（假设没有头部），数据部分为48字节
  - 这些小包 tinygram 会造成相当高的网络传输代价
- Nagle 算法要求
  - 当一个TCP连接中有在传数据（已发送但未经确认），小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都受到ACK
  - 在收到ACK后，TCP需要收集这些小数据，将其正和岛一个报文段中发送
  - 这种方法迫使 TCP 遵循 stop-and-wait 规程
    - 只有等接收到所有在传数据的ACK后才能继续发送
- 这种算法精妙之处在于其实现了 self-clocking 控制：
  - ACK返回越快，数据传输的越快

- RTT控制着发包速率
- <img src="https://i.loli.net/2021/10/12/SfurTXNzvknH8wy.png" alt="image-20210905144037776" style="zoom:50%;" />

### 延时ACK与Nagle算法结合

- 若将延时ACK与Nagle算法直接结合，效果会很差，导致了某种程度上的死锁
- 在某些情况下，如ssh传输，可以禁用Nagle 算法



## 流量控制与窗口管理

### 滑动窗口

- TCP连接的每一端都可收发数据

- 连接的收发数据量是通过一组 window structure 来维护的

- 每个TCP活动连接的两端都维护一个 send window structure 和 receive windows structure

- <img src="https://i.loli.net/2021/10/12/kEFVO69TjqCZ8nA.png" alt="image-20210905144828231" style="zoom:50%;" />

- TCP 以字节（而不是包）为单位来维护其窗口结构

- 由接收端通告的窗口称为 offered window，包含 4 ~ 9字节

- 接收端已成功确认包括第3字节在内的之前的数据，并通告了一个 6 字节大小的窗口

- 窗口大小字段相对 ACK 号有一个字节的偏移量

- 发送端计算其可用窗口，即它可以立即发送的数据量

- 可用窗口 = 提供窗口大小 - 在传数据值

- 变量 SND.UNA 记录窗口左边界和

-  SND.WND 记录提供窗口值

- SND.NXT 记录下次发送的数据序列号

- 可用窗口值 = SND.UNA + SND.WND - SND.NXT

- 当接收到返回的数据ACK，滑动窗口也随之右移

- 窗口两端的相对运动会使窗口增大或减小

  - close，即窗口左边界右移，当已发送数据收到ACK确认之后
  - open，即窗口右边界左移，当已确认数据得到处理，接收端可用缓存变大，窗口也随之变大
  - shrink，即窗口右边界左移

- 每个TCP报文段都包含ACK号和窗口通告信息，TCP发送端可以据此调节窗口结构

- 窗口左边界不能左移，因为其控制的是已确认的ACK号，具有累积性，不能返回

- 零窗口：左右边界相等

  - 此时，TCP发送端开始探测(probe) 对方窗口，伺机增大提供窗口

- 接收端也维护一个窗口结构，但比发送端窗口简单

  - 该窗口结构记录了已接收并确认的数据，以及能够接收的最大序列号
  - 可以保证其接收数据的正确性，特别是，接收端希望避免存储重复的已接收和确认的数据，以及避免存储不应接受的数据

  - <img src="https://i.loli.net/2021/10/12/5qdybKOxL3JHSto.png" alt="image-20210905150001249" style="zoom:50%;" />

- 与发送窗口一样，该窗口结构也包含一个左边界和一个右边界，但窗口内的字节并没有区分

  - 对于接收端来说，到达序列号小于做窗口边界(RCV.NXT)，被认为是重复数据而被丢弃
  - 由于TCP的累积ACK结构，只有当到达数据序列号等于左边界时，数据才不会被丢弃，窗口才能向前滑动
  - 对于选择确认TCP来说，使用SACK选项，窗口内的其他报文段也可以被接收确认，但只有接收到等于左边界的序列号数据时，窗口才能前移



### 零窗口与TCP持续计时器

- TCP是通过接收端的通告窗口来实现流量控制的
- 通告窗口指示了接收端可以接收的数据量
- 当窗口值变为0时，可以有效组织发送端继续发送，直到窗口大小恢复为非零值
- 当接收端重新获得可用空间时，会给发送端传输一个 window update
- 窗口更新通常不包含数据，为纯ACK，不能保证其传输的可靠性
- 如果一个包含窗口更新的ACK丢失，通信双方就会一直处于等待状态
  - 接收方等待接收数据，发送方等待接收窗口更新
  - 为了防止这种死锁的发生，发送端会采用一个持续计时器间歇性查询接收端，查看其窗口是否已增长
- 持续计时器会触发 window probe 的传输，强制要求接收端返回ACK，其中包含了窗口大小的字段
- 主机需求RFC [RFCl122] 建议在一个RTO之后发送第一个窗日探测, 随后以指数时间间隔发送
- 窗口探测包含一个字节的数据，采用TCP可靠传输（丢失重传），因此可以避免由窗口更新丢失导致的死锁
- 当TCP持续计时器超时，就会触发窗口探测的发送
  - 其中一个字节的数据是否能够被接收，取决于接收端的可用缓存空间大小
- TCP不会停止发送窗口探测，由此可能会放弃执行重传操作
  - 可能会导致某种程度的资源耗尽
- 一些总结
  -  发送端不必传输整个窗口大小的数据
  - .接收到返回的ACK的同时可将窗口右移这是由于通告窗口是和该报文段中的ACK号相关的
  - 窗口大小可能减小，但窗口右边界不会左移. 以此避免窗口收缩
  - 接收端不必等到窗口满才发送ACK



### 糊涂窗口综合征 Silly Window Syndrome SWS

- 基于窗口的流量控制机制，尤其是不适用大小固定的报文段的情况，可能会出现SWS
  - 此时，交换数据段的大小不是全长，而是一些较小的数据段
  - 由于每个报文段中有用数据相对于头部信息的比例较小，因此耗费的资源也更多，相应的传输效率也更低
- 接收端的通告窗口较小（没有等待窗口变大）或发送端发送的数据段较小（没有等待其他数据组合成一个更大的报文段）
- 避免SWS的方法
- 对于接收端
  - 不应通告小的窗口值
  - 在窗口可增长至一个全长的报文段（即接收端的MSS）或接收端缓存空间的一般（去两者之间较小者）之前，不通告比当前窗口更大的窗口值
  - 当应用程序处理接收到的数据后使得可用缓存增大
  - TCP接收端需要强制返回对窗口探测的响应
- 对于发送端
  - 不应发送小的报文段，而且需要由Nagle 算法控制何时发送
  - 为了避免SWS，至少满足下列条件之一时才能传输报文段
    1. 全长（发送MSS字节）的报文段可以发送
    2. 数据段长度>= 接收端通告过的最大窗口值的一半
    3. 某ACK不是目前期盼的（没有未经确认的在传数据）
    4. 该连接禁用Nagle算法
  - 使用Naglc 算法附止发送小的报文段，究竟多小才针小？
    - 从条件( 1 ) 可出有出，“小”意昧着宁节数要小于SMSS( 即不超过PMTU 或 接收端MSS 的最大包大小)
    - 条件( 2 )只用于比较旧的原始主机，或者因接收端缓存有限而使用较小通告窗口时
  - （2）要求发送端记录接收端通告窗口的最大值
    - 发送段以此猜测接收端缓存大小，尽管连接建立缓存大小可能减小，但实际这种情况很少见



### 大容量缓存与自动调优

