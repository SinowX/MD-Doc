# TCP超时与重传

- TCP为保证数据传输的正确性，重传其认为已经丢失的包
- TCP拥有两套独立机制来完成重传
  - 基于时间
  - 基于确认信息的构成（通常更高效）
- TCP在发送数据时会设置一个计时器，若计时器超时仍未受到数据确认信息，则会引发相应的超时或基于计时器的重传操作（RTO）
- 快速重传
  - 通常发生在没有延时的情况下，若TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认信息SACK表明出现失序报文段时，快速重传会推断出先丢包
- 发送端认为接收端可能出现数据丢失时，需要决定发送新（未发送过的）数据还是重传

## 简单超时与重传举例

### 基于计时器的重传策略

- 先建立一个连接，并发送一些数据验证连接正常
- 然后断开连接的一端，这时再发送一些数据，观察TCP的操作
- <img src="https://i.loli.net/2021/10/12/SoY1qEyxbNPg9Kk.png" alt="image-20210905155429564" style="zoom:50%;" />
- 每次重传间隔时间加倍称为二进制数退避 binary exponential backoff
- TCP拥有两个阈值来决定如何重传同一个报文段
  - R1 表示TCP在向IP层传递“消极建议”前，愿意尝试重传的次数或等待的时间
  - R2（大于R1）指示TCP应放弃当前连接的时机
  - R1 至少设为三次重传，R2至少设为100秒
  - 对于连接建立的过程（发送SYN报文段），阈值设置和数据段传输有所区别
    - 对于SYN，R2最少设置为3分钟
- Linux中，
  - 对于一般数据段来说，R1和R2可通过修改net.ipv4.tcp_retries1和net.ipv4.tcp_retries2 来设置，单位为重传次数
  - net.ipv4.tcp_retries2 默认为15，对应约13~30分钟，取决于具体连接的 RTO
  - 对于SYN报文段，变量net.ipv4.tcp_syn_retries 和 net.ipv4.tcp_synack_retries 限定重传次数





## 设置重传超时 ROT

- TCP超时和重传的基础是怎样根据给定连接的RTT来设置RTO
- RTT的测量较为复杂，根据路由与网络资源的不同，它会随着时间而改变，TCP必须跟踪这些变化并适时做出调整来维持更好的性能

- 数据接收方可在ACK中携带一个字节的数据来测量该确认信息所需的时间，每个此类的测量结果被称为RTT样本 RTT sample
- TCP首先根据一段时间内的样本值建立好的估计值
  - 然后基于估计值设置RTO
- RTO设置得当是保证TCP性能的关键

### 经典方法

#### 最初的方法 平滑的RTT估计值 SRTT

- $SRTT \gets \alpha(SRTT)+(1-\alpha)RTT$
- SRTT基于现存值和新的样本值$RTT_s$得到更新的结果
- $\alpha$ 为平滑因子，推荐值为 0.8~0.9
- 这种估算方法被称为 Exponentially Weighted Moving Average EWMA 或 low-pass filter

#### 经典方法

- $RTO = min(ubound, max(lbound,(SRRT)\beta))$
- $\beta$ 为时延因子，推荐值为1.3~2.0
- ubound 为 RTO上边界，建议 1分钟
- lbound 为 RTO 下边界，建议 1秒

- 经典方法运行在 RTT变化较大的网络中，效果不好



### 标准方法



### Linux方法





## 基于计时器的重传



## 快速重传





## 带确认的重传



## 伪超时与重传





## 包丢失与包重复







## 目的度量





## 重新组包







